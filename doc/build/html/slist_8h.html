<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MyOs: myos/lib/slist.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MyOs
   &#160;<span id="projectnumber">0.0.0</span>
   </div>
   <div id="projectbrief">MyOs based on Contiki-Os concepts for memory constrained microcontrollers.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('slist_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">slist.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Circular singly linked list.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for slist.h:</div>
<div class="dyncontent">
<div class="center"><img src="slist_8h__incl.png" border="0" usemap="#amyos_2lib_2slist_8h" alt=""/></div>
<map name="amyos_2lib_2slist_8h" id="amyos_2lib_2slist_8h">
<area shape="rect" title="Circular singly linked list." alt="" coords="33,5,154,32"/>
<area shape="rect" title=" " alt="" coords="5,80,80,107"/>
<area shape="rect" title=" " alt="" coords="104,80,187,107"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="slist_8h__dep__incl.png" border="0" usemap="#amyos_2lib_2slist_8hdep" alt=""/></div>
<map name="amyos_2lib_2slist_8hdep" id="amyos_2lib_2slist_8hdep">
<area shape="rect" title="Circular singly linked list." alt="" coords="5,5,127,32"/>
<area shape="rect" href="slist_8c.html" title="Circular singly linked list." alt="" coords="6,80,126,107"/>
</map>
</div>
</div>
<p><a href="slist_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structslist__node__t.html">slist_node_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure representing a node in a circular singly linked list.  <a href="structslist__node__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a716336a5121f9dd051810d65a356c16c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#a716336a5121f9dd051810d65a356c16c">SLIST_NODE_TYPE</a>&#160;&#160;&#160;<a class="el" href="structslist__node__t.html">slist_node_t</a> slist_node</td></tr>
<tr class="separator:a716336a5121f9dd051810d65a356c16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ede917be2b8cfef71f4084a40cedebc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#a9ede917be2b8cfef71f4084a40cedebc">slist_next</a>(slist,  node)&#160;&#160;&#160;    (((<a class="el" href="structslist__node__t.html">slist_node_t</a>*)(node))-&gt;next)</td></tr>
<tr class="memdesc:a9ede917be2b8cfef71f4084a40cedebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to obtain the next node in a circular singly linked list.  <a href="slist_8h.html#a9ede917be2b8cfef71f4084a40cedebc">More...</a><br /></td></tr>
<tr class="separator:a9ede917be2b8cfef71f4084a40cedebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeadaebf6d4d904d4b7244643352f4850"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#aeadaebf6d4d904d4b7244643352f4850">slist_init</a>(slist)&#160;&#160;&#160;    do{<a class="el" href="slist_8h.html#a9ede917be2b8cfef71f4084a40cedebc">slist_next</a>(slist,slist) = (slist);}while(0)</td></tr>
<tr class="memdesc:aeadaebf6d4d904d4b7244643352f4850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a circular singly linked list.  <a href="slist_8h.html#aeadaebf6d4d904d4b7244643352f4850">More...</a><br /></td></tr>
<tr class="separator:aeadaebf6d4d904d4b7244643352f4850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad770ed3a91372fe49a3d4dba83f650f5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#ad770ed3a91372fe49a3d4dba83f650f5">slist_begin</a>(slist)&#160;&#160;&#160;((slist)-&gt;next)</td></tr>
<tr class="memdesc:ad770ed3a91372fe49a3d4dba83f650f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning of a circular singly linked list.  <a href="slist_8h.html#ad770ed3a91372fe49a3d4dba83f650f5">More...</a><br /></td></tr>
<tr class="separator:ad770ed3a91372fe49a3d4dba83f650f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d2c6ee748ea1c5c25f349b245b79576"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#a2d2c6ee748ea1c5c25f349b245b79576">slist_front</a>(slist)&#160;&#160;&#160;(<a class="el" href="slist_8h.html#ad770ed3a91372fe49a3d4dba83f650f5">slist_begin</a>(slist))</td></tr>
<tr class="memdesc:a2d2c6ee748ea1c5c25f349b245b79576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the first element in a circular singly linked list.  <a href="slist_8h.html#a2d2c6ee748ea1c5c25f349b245b79576">More...</a><br /></td></tr>
<tr class="separator:a2d2c6ee748ea1c5c25f349b245b79576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a55ae00593db3acc4726b9cf6bdfe98"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#a4a55ae00593db3acc4726b9cf6bdfe98">slist_end</a>(slist)&#160;&#160;&#160;(slist)</td></tr>
<tr class="memdesc:a4a55ae00593db3acc4726b9cf6bdfe98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the past-the-end element in a circular singly linked list.  <a href="slist_8h.html#a4a55ae00593db3acc4726b9cf6bdfe98">More...</a><br /></td></tr>
<tr class="separator:a4a55ae00593db3acc4726b9cf6bdfe98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d35073f0f3dc5ed25362ed4a4777a18"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#a4d35073f0f3dc5ed25362ed4a4777a18">slist_foreach</a>(slist,  iterator)</td></tr>
<tr class="memdesc:a4d35073f0f3dc5ed25362ed4a4777a18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates through all elements in a circular singly linked list.  <a href="slist_8h.html#a4d35073f0f3dc5ed25362ed4a4777a18">More...</a><br /></td></tr>
<tr class="separator:a4d35073f0f3dc5ed25362ed4a4777a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b02a2ed9d13f16f44b09ead8135f34f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#a6b02a2ed9d13f16f44b09ead8135f34f">slist_empty</a>(slist)&#160;&#160;&#160;((slist)-&gt;next==(slist))</td></tr>
<tr class="memdesc:a6b02a2ed9d13f16f44b09ead8135f34f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether a circular singly linked list is empty.  <a href="slist_8h.html#a6b02a2ed9d13f16f44b09ead8135f34f">More...</a><br /></td></tr>
<tr class="separator:a6b02a2ed9d13f16f44b09ead8135f34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ecf83b22259960a0638a95f26c2c1a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#af8ecf83b22259960a0638a95f26c2c1a">slist_push_front</a>(slist,  node_to_add)</td></tr>
<tr class="memdesc:af8ecf83b22259960a0638a95f26c2c1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element at the beginning of a circular singly linked list.  <a href="slist_8h.html#af8ecf83b22259960a0638a95f26c2c1a">More...</a><br /></td></tr>
<tr class="separator:af8ecf83b22259960a0638a95f26c2c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac357be3f459cf0145048e58f0e8aef8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#aac357be3f459cf0145048e58f0e8aef8">slist_pop_front</a>(slist)&#160;&#160;&#160;    do{(slist)-&gt;next = (slist)-&gt;next-&gt;next;}while(0)</td></tr>
<tr class="memdesc:aac357be3f459cf0145048e58f0e8aef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the first element from a circular singly linked list.  <a href="slist_8h.html#aac357be3f459cf0145048e58f0e8aef8">More...</a><br /></td></tr>
<tr class="separator:aac357be3f459cf0145048e58f0e8aef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08aa73f25c13159c8f4774d2c5d77262"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#a08aa73f25c13159c8f4774d2c5d77262">slist_push_back</a>(slist,  node_to_add)</td></tr>
<tr class="memdesc:a08aa73f25c13159c8f4774d2c5d77262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element at the end of a circular singly linked list.  <a href="slist_8h.html#a08aa73f25c13159c8f4774d2c5d77262">More...</a><br /></td></tr>
<tr class="separator:a08aa73f25c13159c8f4774d2c5d77262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba3584983b49063644e5f42f7afb3552"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#aba3584983b49063644e5f42f7afb3552">slist_insert_after</a>(slistptr,  posptr,  nodeptr)</td></tr>
<tr class="memdesc:aba3584983b49063644e5f42f7afb3552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a node after a specified position in a circular singly linked list.  <a href="slist_8h.html#aba3584983b49063644e5f42f7afb3552">More...</a><br /></td></tr>
<tr class="separator:aba3584983b49063644e5f42f7afb3552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb25b7731ac348631e2843077f9be197"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#acb25b7731ac348631e2843077f9be197">slist_insert_before</a>(slist,  posptr,  nodeptr)</td></tr>
<tr class="memdesc:acb25b7731ac348631e2843077f9be197"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a node before a specified position in a circular singly linked list.  <a href="slist_8h.html#acb25b7731ac348631e2843077f9be197">More...</a><br /></td></tr>
<tr class="separator:acb25b7731ac348631e2843077f9be197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6bb9d48b1bf8d80d6a3ce855d6afd2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#acf6bb9d48b1bf8d80d6a3ce855d6afd2">slist_clear</a>(slistptr)&#160;&#160;&#160;    <a class="el" href="slist_8h.html#aeadaebf6d4d904d4b7244643352f4850">slist_init</a>(slistptr)</td></tr>
<tr class="memdesc:acf6bb9d48b1bf8d80d6a3ce855d6afd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears a circular singly linked list.  <a href="slist_8h.html#acf6bb9d48b1bf8d80d6a3ce855d6afd2">More...</a><br /></td></tr>
<tr class="separator:acf6bb9d48b1bf8d80d6a3ce855d6afd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0773a47d8b00e244e5df9836c14a3b4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#aa0773a47d8b00e244e5df9836c14a3b4">slist_erase</a>(slistptr,  nodeptr)</td></tr>
<tr class="memdesc:aa0773a47d8b00e244e5df9836c14a3b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a specific node from a circular singly linked list.  <a href="slist_8h.html#aa0773a47d8b00e244e5df9836c14a3b4">More...</a><br /></td></tr>
<tr class="separator:aa0773a47d8b00e244e5df9836c14a3b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a264d4c34b7aadd955a0e307beddcafa3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#a264d4c34b7aadd955a0e307beddcafa3">slist_pop_back</a>(slist)</td></tr>
<tr class="memdesc:a264d4c34b7aadd955a0e307beddcafa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last element from a circular singly linked list.  <a href="slist_8h.html#a264d4c34b7aadd955a0e307beddcafa3">More...</a><br /></td></tr>
<tr class="separator:a264d4c34b7aadd955a0e307beddcafa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a807626e58194903cd491ab5b3aa82f9c"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structslist__node__t.html">slist_node_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#a807626e58194903cd491ab5b3aa82f9c">slist_node_t</a></td></tr>
<tr class="memdesc:a807626e58194903cd491ab5b3aa82f9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for the structure representing a node in a circular singly linked list.  <a href="slist_8h.html#a807626e58194903cd491ab5b3aa82f9c">More...</a><br /></td></tr>
<tr class="separator:a807626e58194903cd491ab5b3aa82f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac626c3ba7de6d820620343dfc50fd279"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structslist__node__t.html">slist_node_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#ac626c3ba7de6d820620343dfc50fd279">slist_t</a></td></tr>
<tr class="memdesc:ac626c3ba7de6d820620343dfc50fd279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for the circular singly linked list.  <a href="slist_8h.html#ac626c3ba7de6d820620343dfc50fd279">More...</a><br /></td></tr>
<tr class="separator:ac626c3ba7de6d820620343dfc50fd279"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a251765371febfc140be13cb5b785267d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structslist__node__t.html">slist_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#a251765371febfc140be13cb5b785267d">slist_prev</a> (<a class="el" href="slist_8h.html#ac626c3ba7de6d820620343dfc50fd279">slist_t</a> *slist, void *existing_node)</td></tr>
<tr class="memdesc:a251765371febfc140be13cb5b785267d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the previous node in a circular singly linked list.  <a href="slist_8h.html#a251765371febfc140be13cb5b785267d">More...</a><br /></td></tr>
<tr class="separator:a251765371febfc140be13cb5b785267d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a382fcc84d290b85188e910d4d65b3e13"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#a382fcc84d290b85188e910d4d65b3e13">slist_size</a> (<a class="el" href="slist_8h.html#ac626c3ba7de6d820620343dfc50fd279">slist_t</a> *slist)</td></tr>
<tr class="memdesc:a382fcc84d290b85188e910d4d65b3e13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of nodes in a circular singly linked list.  <a href="slist_8h.html#a382fcc84d290b85188e910d4d65b3e13">More...</a><br /></td></tr>
<tr class="separator:a382fcc84d290b85188e910d4d65b3e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41421643834ad4e06e0d41811c105221"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structslist__node__t.html">slist_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#a41421643834ad4e06e0d41811c105221">slist_back</a> (<a class="el" href="slist_8h.html#ac626c3ba7de6d820620343dfc50fd279">slist_t</a> *slist)</td></tr>
<tr class="memdesc:a41421643834ad4e06e0d41811c105221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last node in a circular singly linked list.  <a href="slist_8h.html#a41421643834ad4e06e0d41811c105221">More...</a><br /></td></tr>
<tr class="separator:a41421643834ad4e06e0d41811c105221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b4d20ae442d1ad98748fafae052c32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structslist__node__t.html">slist_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#ab2b4d20ae442d1ad98748fafae052c32">slist_prev_prev</a> (<a class="el" href="slist_8h.html#ac626c3ba7de6d820620343dfc50fd279">slist_t</a> *slist, void *node)</td></tr>
<tr class="memdesc:ab2b4d20ae442d1ad98748fafae052c32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the node two steps behind a specified node in a circular singly linked list.  <a href="slist_8h.html#ab2b4d20ae442d1ad98748fafae052c32">More...</a><br /></td></tr>
<tr class="separator:ab2b4d20ae442d1ad98748fafae052c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50bb2ab18efd8562fbc4882346d74f2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structslist__node__t.html">slist_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8h.html#a50bb2ab18efd8562fbc4882346d74f2c">slist_find</a> (<a class="el" href="slist_8h.html#ac626c3ba7de6d820620343dfc50fd279">slist_t</a> *slist, void *node)</td></tr>
<tr class="memdesc:a50bb2ab18efd8562fbc4882346d74f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for a specific node in a circular singly linked list.  <a href="slist_8h.html#a50bb2ab18efd8562fbc4882346d74f2c">More...</a><br /></td></tr>
<tr class="separator:a50bb2ab18efd8562fbc4882346d74f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Circular singly linked list. </p>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright 2013-2023 Marco Bacchi <a href="#" onclick="location.href='mai'+'lto:'+'mar'+'co'+'@ba'+'cc'+'hi.'+'at'; return false;">marco<span style="display: none;">.nosp@m.</span>@bac<span style="display: none;">.nosp@m.</span>chi.a<span style="display: none;">.nosp@m.</span>t</a> </dd></dl>
<dl class="section user"><dt>License:</dt><dd>This file is released under the MIT License.<br  />
 <a href="https://opensource.org/licenses/MIT">https://opensource.org/licenses/MIT</a></dd></dl>
<p>In computer science, a linked list is a linear collection of data elements, whose order is not given by their physical placement in memory. Instead, each element points to the next. It is a data structure consisting of a collection of nodes which together represent a sequence. In its most basic form, each node contains: data, and a reference (in other words, a link) to the next node in the sequence. This structure allows for efficient insertion or removal of elements from any position in the sequence during iteration. More info at <a href="https://en.wikipedia.org/wiki/Linked_list">https://en.wikipedia.org/wiki/Linked_list</a></p>
<p>Singly linked lists contain nodes which have a data field as well as 'next' field, which points to the next node in line of nodes. Operations that can be performed on singly linked lists include insertion, deletion, and traversal. More info at <a href="https://en.wikipedia.org/wiki/Linked_list#Singly_linked_list">https://en.wikipedia.org/wiki/Linked_list#Singly_linked_list</a></p>
<p>In the last node of a list, the link field often contains a null reference, a special value used to indicate the lack of further nodes. A less common convention is to make it point to the first node of the list; in that case, the list is said to be 'circular' or 'circularly linked'; otherwise, it is said to be 'open' or 'linear'. It is a list where the last pointer points to the first node. More info at <a href="https://en.wikipedia.org/wiki/Linked_list#Circular_linked_list">https://en.wikipedia.org/wiki/Linked_list#Circular_linked_list</a></p>
<p>Comparison Singly Linked List vs. Arrays:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Arrays   </th><th class="markdownTableHeadNone">Singly Linked List    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Arrays are stored in a continuous location.   </td><td class="markdownTableBodyNone">Linked lists are not stored in contiguous locations.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Fixed size.   </td><td class="markdownTableBodyNone">Dynamic in size.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Memory is allocated at compile time.   </td><td class="markdownTableBodyNone">Memory is allocated at run time (not necessarily true).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Uses less memory than linked lists.   </td><td class="markdownTableBodyNone">Uses more memory because it stores both data and the address of the next node.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Elements can be accessed easily.   </td><td class="markdownTableBodyNone">Insertion and deletion operations are faster.   </td></tr>
</table>
<p>Nomenclature (applies for slist and dlist):</p>
<p><img src="slist/slist_nomenclature.png" alt="Nomenclature (applies for slist and dlist)" class="inline"/>{html: width=640px, latex: width=5cm}</p>
<p>This file was redocumented in doxygen style format by using ChatGPT 4. <br  />
 Input : existing doxygen documentation and source for each documentation entity <br  />
 Request : Extend doxygen documentation part <br  />
 Output : New doxygen documentation <br  />
</p>

<p class="definition">Definition in file <a class="el" href="slist_8h_source.html">slist.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ad770ed3a91372fe49a3d4dba83f650f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad770ed3a91372fe49a3d4dba83f650f5">&#9670;&nbsp;</a></span>slist_begin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define slist_begin</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">slist</td><td>)</td>
          <td>&#160;&#160;&#160;((slist)-&gt;next)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning of a circular singly linked list. </p>
<p>This macro provides an iterator pointing to the first element in a circular singly linked list. Since the head node of the list also serves as a part of the list, this macro returns the 'next' pointer of the head node. If the list is empty (i.e., the head's 'next' pointer points back to the head), this iterator will point to the head node itself, indicating that there are no elements in the list.</p>
<p>The <code>slist_begin</code> macro is useful for accessing the first element of the list, especially when iterating over the list or performing operations on the elements. It is important to check if the list is empty before dereferencing the returned iterator.</p>
<p>Usage: </p><div class="fragment"><div class="line"><a class="code" href="structslist__node__t.html">slist_node_t</a> mylist;</div>
<div class="line"><a class="code" href="slist_8h.html#aeadaebf6d4d904d4b7244643352f4850">slist_init</a>(&amp;mylist);</div>
<div class="line"><span class="comment">// Add elements to the list</span></div>
<div class="line"><a class="code" href="structslist__node__t.html">slist_node_t</a> *begin = <a class="code" href="slist_8h.html#ad770ed3a91372fe49a3d4dba83f650f5">slist_begin</a>(&amp;mylist);</div>
<div class="line"><span class="keywordflow">if</span> (begin != &amp;mylist) {</div>
<div class="line">    <span class="comment">// The list is not empty, process the first element</span></div>
<div class="line">}</div>
<div class="ttc" id="aslist_8h_html_ad770ed3a91372fe49a3d4dba83f650f5"><div class="ttname"><a href="slist_8h.html#ad770ed3a91372fe49a3d4dba83f650f5">slist_begin</a></div><div class="ttdeci">#define slist_begin(slist)</div><div class="ttdoc">Returns an iterator to the beginning of a circular singly linked list.</div><div class="ttdef"><b>Definition:</b> <a href="slist_8h_source.html#l00166">slist.h:166</a></div></div>
<div class="ttc" id="aslist_8h_html_aeadaebf6d4d904d4b7244643352f4850"><div class="ttname"><a href="slist_8h.html#aeadaebf6d4d904d4b7244643352f4850">slist_init</a></div><div class="ttdeci">#define slist_init(slist)</div><div class="ttdoc">Initializes a circular singly linked list.</div><div class="ttdef"><b>Definition:</b> <a href="slist_8h_source.html#l00134">slist.h:134</a></div></div>
<div class="ttc" id="astructslist__node__t_html"><div class="ttname"><a href="structslist__node__t.html">slist_node_t</a></div><div class="ttdoc">Structure representing a node in a circular singly linked list.</div><div class="ttdef"><b>Definition:</b> <a href="slist_8h_source.html#l00555">slist.h:555</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slist</td><td>A pointer to the head of the circular singly linked list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator (pointer) to the first element in the list, or to the head node itself if the list is empty. </dd></dl>

<p class="definition">Definition at line <a class="el" href="slist_8h_source.html#l00166">166</a> of file <a class="el" href="slist_8h_source.html">slist.h</a>.</p>

</div>
</div>
<a id="acf6bb9d48b1bf8d80d6a3ce855d6afd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf6bb9d48b1bf8d80d6a3ce855d6afd2">&#9670;&nbsp;</a></span>slist_clear</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define slist_clear</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">slistptr</td><td>)</td>
          <td>&#160;&#160;&#160;    <a class="el" href="slist_8h.html#aeadaebf6d4d904d4b7244643352f4850">slist_init</a>(slistptr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears a circular singly linked list. </p>
<p>This macro clears the contents of a circular singly linked list. It reinitializes the list by setting the 'next' pointer of the head node to point to itself, effectively marking the list as empty. This operation resets the list to its initial state, with no nodes linked to the head.</p>
<p>It is important to note that this macro only resets the list structure; it does not free the memory associated with the nodes in the list. If the nodes were dynamically allocated, the user should ensure that they are properly freed before clearing the list to avoid memory leaks.</p>
<p>Usage: </p><div class="fragment"><div class="line"><a class="code" href="structslist__node__t.html">slist_node_t</a> mylist;</div>
<div class="line"><a class="code" href="slist_8h.html#aeadaebf6d4d904d4b7244643352f4850">slist_init</a>(&amp;mylist);</div>
<div class="line"><span class="comment">// Add elements and perform operations on the list</span></div>
<div class="line"><a class="code" href="slist_8h.html#acf6bb9d48b1bf8d80d6a3ce855d6afd2">slist_clear</a>(&amp;mylist);</div>
<div class="line"><span class="comment">// Now &#39;mylist&#39; is cleared and reset to its initial state</span></div>
<div class="ttc" id="aslist_8h_html_acf6bb9d48b1bf8d80d6a3ce855d6afd2"><div class="ttname"><a href="slist_8h.html#acf6bb9d48b1bf8d80d6a3ce855d6afd2">slist_clear</a></div><div class="ttdeci">#define slist_clear(slistptr)</div><div class="ttdoc">Clears a circular singly linked list.</div><div class="ttdef"><b>Definition:</b> <a href="slist_8h_source.html#l00494">slist.h:494</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slistptr</td><td>A pointer to the circular singly linked list to be cleared. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="slist_8h_source.html#l00494">494</a> of file <a class="el" href="slist_8h_source.html">slist.h</a>.</p>

</div>
</div>
<a id="a6b02a2ed9d13f16f44b09ead8135f34f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b02a2ed9d13f16f44b09ead8135f34f">&#9670;&nbsp;</a></span>slist_empty</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define slist_empty</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">slist</td><td>)</td>
          <td>&#160;&#160;&#160;((slist)-&gt;next==(slist))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether a circular singly linked list is empty. </p>
<p>This macro checks if a circular singly linked list is empty by comparing the 'next' pointer of the head node (<code>slist</code>) to the address of the head node itself. In an empty circular singly linked list, the 'next' pointer of the head node points to the head node, indicating that there are no other nodes in the list. This quick check allows for determining if the list contains any elements without traversing the list.</p>
<p>It is particularly useful for checking the state of the list before performing operations that require the list to contain elements.</p>
<p>Usage: </p><div class="fragment"><div class="line"><a class="code" href="structslist__node__t.html">slist_node_t</a> mylist;</div>
<div class="line"><a class="code" href="slist_8h.html#aeadaebf6d4d904d4b7244643352f4850">slist_init</a>(&amp;mylist);</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="slist_8h.html#a6b02a2ed9d13f16f44b09ead8135f34f">slist_empty</a>(&amp;mylist)) {</div>
<div class="line">    <span class="comment">// The list is empty</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// The list contains elements</span></div>
<div class="line">}</div>
<div class="ttc" id="aslist_8h_html_a6b02a2ed9d13f16f44b09ead8135f34f"><div class="ttname"><a href="slist_8h.html#a6b02a2ed9d13f16f44b09ead8135f34f">slist_empty</a></div><div class="ttdeci">#define slist_empty(slist)</div><div class="ttdoc">Tests whether a circular singly linked list is empty.</div><div class="ttdef"><b>Definition:</b> <a href="slist_8h_source.html#l00291">slist.h:291</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slist</td><td>A pointer to the head of the circular singly linked list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An integer: 0 if the list is not empty, or 1 if it is empty. </dd></dl>

<p class="definition">Definition at line <a class="el" href="slist_8h_source.html#l00291">291</a> of file <a class="el" href="slist_8h_source.html">slist.h</a>.</p>

</div>
</div>
<a id="a4a55ae00593db3acc4726b9cf6bdfe98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a55ae00593db3acc4726b9cf6bdfe98">&#9670;&nbsp;</a></span>slist_end</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define slist_end</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">slist</td><td>)</td>
          <td>&#160;&#160;&#160;(slist)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the past-the-end element in a circular singly linked list. </p>
<p>This macro provides an iterator referring to the past-the-end element in a circular singly linked list. The past-the-end element is a theoretical element that follows the last element in the list. It is not a valid element and thus shall not be dereferenced. This iterator is commonly used in combination with <code>slist_begin</code> to specify a range that includes all the elements in the container.</p>
<p>In a circular singly linked list, the past-the-end element is represented by the list node itself. As such, this macro returns the list node, signifying the end of the list. This is particularly useful for loop conditions and iterator comparisons where a sentinel value is needed to represent the end of the list.</p>
<p>Usage: </p><div class="fragment"><div class="line"><a class="code" href="structslist__node__t.html">slist_node_t</a> mylist;</div>
<div class="line"><a class="code" href="slist_8h.html#aeadaebf6d4d904d4b7244643352f4850">slist_init</a>(&amp;mylist);</div>
<div class="line"><span class="comment">// Add elements to the list</span></div>
<div class="line"><span class="keywordflow">for</span> (<a class="code" href="structslist__node__t.html">slist_node_t</a> *it = <a class="code" href="slist_8h.html#ad770ed3a91372fe49a3d4dba83f650f5">slist_begin</a>(&amp;mylist); it != <a class="code" href="slist_8h.html#a4a55ae00593db3acc4726b9cf6bdfe98">slist_end</a>(&amp;mylist); it = <a class="code" href="slist_8h.html#a9ede917be2b8cfef71f4084a40cedebc">slist_next</a>(&amp;mylist, it)) {</div>
<div class="line">    <span class="comment">// Process each element</span></div>
<div class="line">}</div>
<div class="ttc" id="aslist_8h_html_a4a55ae00593db3acc4726b9cf6bdfe98"><div class="ttname"><a href="slist_8h.html#a4a55ae00593db3acc4726b9cf6bdfe98">slist_end</a></div><div class="ttdeci">#define slist_end(slist)</div><div class="ttdoc">Returns an iterator to the past-the-end element in a circular singly linked list.</div><div class="ttdef"><b>Definition:</b> <a href="slist_8h_source.html#l00226">slist.h:226</a></div></div>
<div class="ttc" id="aslist_8h_html_a9ede917be2b8cfef71f4084a40cedebc"><div class="ttname"><a href="slist_8h.html#a9ede917be2b8cfef71f4084a40cedebc">slist_next</a></div><div class="ttdeci">#define slist_next(slist, node)</div><div class="ttdoc">Macro to obtain the next node in a circular singly linked list.</div><div class="ttdef"><b>Definition:</b> <a href="slist_8h_source.html#l00109">slist.h:109</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slist</td><td>A pointer to the head of the circular singly linked list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator referring to the past-the-end element, which is the list node itself. </dd></dl>

<p class="definition">Definition at line <a class="el" href="slist_8h_source.html#l00226">226</a> of file <a class="el" href="slist_8h_source.html">slist.h</a>.</p>

</div>
</div>
<a id="aa0773a47d8b00e244e5df9836c14a3b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0773a47d8b00e244e5df9836c14a3b4">&#9670;&nbsp;</a></span>slist_erase</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define slist_erase</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">slistptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">nodeptr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">do</span>{                                                                             \</div>
<div class="line">        slist_prev(slistptr,nodeptr)-&gt;next = ((<a class="code" href="structslist__node__t.html">slist_node_t</a>*)(nodeptr))-&gt;next;      \</div>
<div class="line">    }<span class="keywordflow">while</span>(0)</div>
</div><!-- fragment -->
<p>Removes a specific node from a circular singly linked list. </p>
<p>This macro removes a specified node (<code>nodeptr</code>) from the circular singly linked list. It accomplishes this by finding the node that precedes <code>nodeptr</code> in the list using <code>slist_prev(slistptr, nodeptr)</code> and then adjusting its 'next' pointer to bypass <code>nodeptr</code>, pointing instead to the node that follows <code>nodeptr</code>. This operation effectively removes <code>nodeptr</code> from the list.</p>
<p>The operation requires finding the previous node, which involves a partial traversal of the list up to <code>nodeptr</code>. It is important to ensure that <code>nodeptr</code> is a valid and existing member of the list before using this macro. Improper usage may lead to undefined behavior.</p>
<p>Note that this macro only removes <code>nodeptr</code> from the list structure; it does not free the memory associated with <code>nodeptr</code>. If <code>nodeptr</code> was dynamically allocated, users are responsible for managing its memory.</p>
<p>Usage: </p><div class="fragment"><div class="line"><a class="code" href="structslist__node__t.html">slist_node_t</a> mylist;</div>
<div class="line"><a class="code" href="slist_8h.html#aeadaebf6d4d904d4b7244643352f4850">slist_init</a>(&amp;mylist);</div>
<div class="line"><span class="comment">// Add elements to the list</span></div>
<div class="line"><a class="code" href="structslist__node__t.html">slist_node_t</a> *node_to_remove = find_node(mylist, some_criteria); <span class="comment">// Assume find_node returns a valid node</span></div>
<div class="line"><span class="keywordflow">if</span> (node_to_remove) {</div>
<div class="line">    <a class="code" href="slist_8h.html#aa0773a47d8b00e244e5df9836c14a3b4">slist_erase</a>(&amp;mylist, node_to_remove);</div>
<div class="line">    <span class="comment">// &#39;node_to_remove&#39; is now removed from &#39;mylist&#39;</span></div>
<div class="line">    <span class="comment">// Free node_to_remove if necessary</span></div>
<div class="line">}</div>
<div class="ttc" id="aslist_8h_html_aa0773a47d8b00e244e5df9836c14a3b4"><div class="ttname"><a href="slist_8h.html#aa0773a47d8b00e244e5df9836c14a3b4">slist_erase</a></div><div class="ttdeci">#define slist_erase(slistptr, nodeptr)</div><div class="ttdoc">Removes a specific node from a circular singly linked list.</div><div class="ttdef"><b>Definition:</b> <a href="slist_8h_source.html#l00531">slist.h:531</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slistptr</td><td>A pointer to the head of the circular singly linked list. </td></tr>
    <tr><td class="paramname">nodeptr</td><td>A pointer to the node to be removed from the list. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="slist_8h_source.html#l00531">531</a> of file <a class="el" href="slist_8h_source.html">slist.h</a>.</p>

</div>
</div>
<a id="a4d35073f0f3dc5ed25362ed4a4777a18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d35073f0f3dc5ed25362ed4a4777a18">&#9670;&nbsp;</a></span>slist_foreach</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define slist_foreach</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">slist, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iterator&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">for</span>(iterator = (<span class="keywordtype">void</span>*)<a class="code" href="slist_8h.html#ad770ed3a91372fe49a3d4dba83f650f5">slist_begin</a>(slist);           \</div>
<div class="line">        ((<a class="code" href="structslist__node__t.html">slist_node_t</a>*)iterator) != <a class="code" href="slist_8h.html#a4a55ae00593db3acc4726b9cf6bdfe98">slist_end</a>(slist);  \</div>
<div class="line">        iterator=(<span class="keywordtype">void</span>*)<a class="code" href="slist_8h.html#a9ede917be2b8cfef71f4084a40cedebc">slist_next</a>(slist,iterator))</div>
</div><!-- fragment -->
<p>Iterates through all elements in a circular singly linked list. </p>
<p>This macro sets up a loop that iterates from the first to the last element in a circular singly linked list. It initializes the iterator to the first element in the list using <code>slist_begin</code>, and then continues to iterate over each element until it reaches the end of the list, indicated by <code>slist_end</code>. This macro is useful for performing operations on each element in the list, such as searching, modifying, or printing values.</p>
<p>The macro uses a for loop to traverse the list, making it easy to apply a block of code to each element. It is important to ensure that the list is properly initialized before using this macro to avoid undefined behavior.</p>
<p>Usage: </p><div class="fragment"><div class="line"><a class="code" href="structslist__node__t.html">slist_node_t</a> mylist;</div>
<div class="line"><a class="code" href="slist_8h.html#aeadaebf6d4d904d4b7244643352f4850">slist_init</a>(&amp;mylist);</div>
<div class="line"><span class="comment">// Add elements to the list</span></div>
<div class="line"><a class="code" href="structslist__node__t.html">slist_node_t</a> *iterator;</div>
<div class="line"><a class="code" href="slist_8h.html#a4d35073f0f3dc5ed25362ed4a4777a18">slist_foreach</a>(&amp;mylist, iterator) {</div>
<div class="line">    <span class="comment">// Process each element pointed to by iterator</span></div>
<div class="line">}</div>
<div class="ttc" id="aslist_8h_html_a4d35073f0f3dc5ed25362ed4a4777a18"><div class="ttname"><a href="slist_8h.html#a4d35073f0f3dc5ed25362ed4a4777a18">slist_foreach</a></div><div class="ttdeci">#define slist_foreach(slist, iterator)</div><div class="ttdoc">Iterates through all elements in a circular singly linked list.</div><div class="ttdef"><b>Definition:</b> <a href="slist_8h_source.html#l00257">slist.h:257</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slist</td><td>A pointer to the head of the circular singly linked list to be iterated over. </td></tr>
    <tr><td class="paramname">iterator</td><td>A pointer that will be used as an iterator over the list. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="slist_8h_source.html#l00257">257</a> of file <a class="el" href="slist_8h_source.html">slist.h</a>.</p>

</div>
</div>
<a id="a2d2c6ee748ea1c5c25f349b245b79576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d2c6ee748ea1c5c25f349b245b79576">&#9670;&nbsp;</a></span>slist_front</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define slist_front</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">slist</td><td>)</td>
          <td>&#160;&#160;&#160;(<a class="el" href="slist_8h.html#ad770ed3a91372fe49a3d4dba83f650f5">slist_begin</a>(slist))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the first element in a circular singly linked list. </p>
<p>This macro provides access to the first data-containing node in a circular singly linked list. It utilizes the <code>slist_begin</code> macro to obtain an iterator pointing to the first element. If the list is empty, this iterator will point back to the head node itself, which should not be treated as a valid data-containing node.</p>
<p>The <code>slist_front</code> macro simplifies accessing the first element of the list. Users should verify that the list is not empty before attempting to use the returned iterator to access list data.</p>
<p>Usage: </p><div class="fragment"><div class="line"><a class="code" href="structslist__node__t.html">slist_node_t</a> mylist;</div>
<div class="line"><a class="code" href="slist_8h.html#aeadaebf6d4d904d4b7244643352f4850">slist_init</a>(&amp;mylist);</div>
<div class="line"><span class="comment">// Add elements to the list</span></div>
<div class="line"><a class="code" href="structslist__node__t.html">slist_node_t</a> *front = <a class="code" href="slist_8h.html#a2d2c6ee748ea1c5c25f349b245b79576">slist_front</a>(&amp;mylist);</div>
<div class="line"><span class="keywordflow">if</span> (front != &amp;mylist) {</div>
<div class="line">    <span class="comment">// The list is not empty, access the data of the first element</span></div>
<div class="line">}</div>
<div class="ttc" id="aslist_8h_html_a2d2c6ee748ea1c5c25f349b245b79576"><div class="ttname"><a href="slist_8h.html#a2d2c6ee748ea1c5c25f349b245b79576">slist_front</a></div><div class="ttdeci">#define slist_front(slist)</div><div class="ttdoc">Retrieves the first element in a circular singly linked list.</div><div class="ttdef"><b>Definition:</b> <a href="slist_8h_source.html#l00195">slist.h:195</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slist</td><td>A pointer to the head of the circular singly linked list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator (pointer) to the first element in the list, or to the head node itself if the list is empty. </dd></dl>

<p class="definition">Definition at line <a class="el" href="slist_8h_source.html#l00195">195</a> of file <a class="el" href="slist_8h_source.html">slist.h</a>.</p>

</div>
</div>
<a id="aeadaebf6d4d904d4b7244643352f4850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeadaebf6d4d904d4b7244643352f4850">&#9670;&nbsp;</a></span>slist_init</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define slist_init</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">slist</td><td>)</td>
          <td>&#160;&#160;&#160;    do{<a class="el" href="slist_8h.html#a9ede917be2b8cfef71f4084a40cedebc">slist_next</a>(slist,slist) = (slist);}while(0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a circular singly linked list. </p>
<p>This macro initializes a circular singly linked list. It sets up the list such that the 'next' pointer of the head node points to the head itself, indicating an empty list. In a circular singly linked list, this condition signifies that there are no other nodes in the list, and the list loops back to the head. This initialization is crucial for the proper functioning of the list, as it establishes the fundamental circular structure of the list.</p>
<p>Proper initialization of the list is essential before performing any other operations on the list, as it ensures that the list is in a known and empty state.</p>
<p>Usage: </p><div class="fragment"><div class="line"><a class="code" href="structslist__node__t.html">slist_node_t</a> mylist;</div>
<div class="line"><a class="code" href="slist_8h.html#aeadaebf6d4d904d4b7244643352f4850">slist_init</a>(&amp;mylist);</div>
<div class="line"><span class="comment">// Now &#39;mylist&#39; is initialized and ready for operations</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slist</td><td>A pointer to the head of the circular singly linked list to be initialized. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="slist_8h_source.html#l00134">134</a> of file <a class="el" href="slist_8h_source.html">slist.h</a>.</p>

</div>
</div>
<a id="aba3584983b49063644e5f42f7afb3552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba3584983b49063644e5f42f7afb3552">&#9670;&nbsp;</a></span>slist_insert_after</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define slist_insert_after</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">slistptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">posptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">nodeptr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">do</span>{ \</div>
<div class="line">        ((<a class="code" href="structslist__node__t.html">slist_node_t</a>*)(nodeptr))-&gt;next = ((<a class="code" href="structslist__node__t.html">slist_node_t</a>*)(posptr))-&gt;next; \</div>
<div class="line">        ((<a class="code" href="structslist__node__t.html">slist_node_t</a>*)(posptr))-&gt;next = ((<a class="code" href="structslist__node__t.html">slist_node_t</a>*)(nodeptr)); \</div>
<div class="line">    }<span class="keywordflow">while</span>(0)</div>
</div><!-- fragment -->
<p>Inserts a node after a specified position in a circular singly linked list. </p>
<p>This macro inserts a new node (<code>nodeptr</code>) into the circular singly linked list immediately after a specified node (<code>posptr</code>). The insertion is achieved by adjusting the 'next' pointer of <code>nodeptr</code> to point to the node that follows <code>posptr</code>, and then updating the 'next' pointer of <code>posptr</code> to point to <code>nodeptr</code>. This operation effectively places <code>nodeptr</code> into the list directly after <code>posptr</code>.</p>
<p>The operation is efficient as it only involves modifying the pointers of <code>posptr</code> and <code>nodeptr</code>, without the need to traverse the entire list. It is crucial that both <code>posptr</code> and <code>nodeptr</code> are valid pointers to nodes and that <code>posptr</code> is an existing member of the list for the macro to function correctly. Improper usage may lead to undefined behavior.</p>
<p>Usage: </p><div class="fragment"><div class="line"><a class="code" href="structslist__node__t.html">slist_node_t</a> mylist;</div>
<div class="line"><a class="code" href="slist_8h.html#aeadaebf6d4d904d4b7244643352f4850">slist_init</a>(&amp;mylist);</div>
<div class="line"><a class="code" href="structslist__node__t.html">slist_node_t</a> *position_node = find_node(mylist, some_criteria); <span class="comment">// Assume find_node returns a valid node</span></div>
<div class="line"><a class="code" href="structslist__node__t.html">slist_node_t</a> *new_node = create_node(data); <span class="comment">// Assume create_node allocates and initializes a new node</span></div>
<div class="line"><a class="code" href="slist_8h.html#aba3584983b49063644e5f42f7afb3552">slist_insert_after</a>(&amp;mylist, position_node, new_node);</div>
<div class="line"><span class="comment">// Now &#39;new_node&#39; is inserted immediately after &#39;position_node&#39; in &#39;mylist&#39;</span></div>
<div class="ttc" id="aslist_8h_html_aba3584983b49063644e5f42f7afb3552"><div class="ttname"><a href="slist_8h.html#aba3584983b49063644e5f42f7afb3552">slist_insert_after</a></div><div class="ttdeci">#define slist_insert_after(slistptr, posptr, nodeptr)</div><div class="ttdoc">Inserts a node after a specified position in a circular singly linked list.</div><div class="ttdef"><b>Definition:</b> <a href="slist_8h_source.html#l00425">slist.h:425</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slistptr</td><td>A pointer to the head of the circular singly linked list. </td></tr>
    <tr><td class="paramname">posptr</td><td>A pointer to the node after which the new node will be inserted. </td></tr>
    <tr><td class="paramname">nodeptr</td><td>A pointer to the new node to be inserted into the list. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="slist_8h_source.html#l00425">425</a> of file <a class="el" href="slist_8h_source.html">slist.h</a>.</p>

</div>
</div>
<a id="acb25b7731ac348631e2843077f9be197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb25b7731ac348631e2843077f9be197">&#9670;&nbsp;</a></span>slist_insert_before</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define slist_insert_before</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">slist, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">posptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">nodeptr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">do</span>{ \</div>
<div class="line">        slist_prev(slist,posptr)-&gt;next = (<a class="code" href="structslist__node__t.html">slist_node_t</a>*)(nodeptr); \</div>
<div class="line">        ((<a class="code" href="structslist__node__t.html">slist_node_t</a>*)nodeptr))-&gt;next = posptr; \</div>
<div class="line">    }<span class="keywordflow">while</span>(0)</div>
</div><!-- fragment -->
<p>Inserts a node before a specified position in a circular singly linked list. </p>
<p>This macro inserts a new node (<code>nodeptr</code>) into the circular singly linked list immediately before a specified node (<code>posptr</code>). The insertion is achieved by adjusting the 'next' pointer of the node that precedes <code>posptr</code>, found using <code>slist_prev(slist, posptr)</code>, to point to <code>nodeptr</code>, and then setting the 'next' pointer of <code>nodeptr</code> to <code>posptr</code>. This operation effectively places <code>nodeptr</code> into the list directly before <code>posptr</code>.</p>
<p>The operation requires finding the previous node, which involves a partial traversal of the list up to <code>posptr</code>. This macro assumes that both <code>posptr</code> and <code>nodeptr</code> are valid pointers to nodes and that <code>posptr</code> is an existing member of the list. Improper usage may lead to undefined behavior.</p>
<p>Usage: </p><div class="fragment"><div class="line"><a class="code" href="structslist__node__t.html">slist_node_t</a> mylist;</div>
<div class="line"><a class="code" href="slist_8h.html#aeadaebf6d4d904d4b7244643352f4850">slist_init</a>(&amp;mylist);</div>
<div class="line"><a class="code" href="structslist__node__t.html">slist_node_t</a> *position_node = find_node(mylist, some_criteria); <span class="comment">// Assume find_node returns a valid node</span></div>
<div class="line"><a class="code" href="structslist__node__t.html">slist_node_t</a> *new_node = create_node(data); <span class="comment">// Assume create_node allocates and initializes a new node</span></div>
<div class="line"><a class="code" href="slist_8h.html#acb25b7731ac348631e2843077f9be197">slist_insert_before</a>(&amp;mylist, position_node, new_node);</div>
<div class="line"><span class="comment">// Now &#39;new_node&#39; is inserted immediately before &#39;position_node&#39; in &#39;mylist&#39;</span></div>
<div class="ttc" id="aslist_8h_html_acb25b7731ac348631e2843077f9be197"><div class="ttname"><a href="slist_8h.html#acb25b7731ac348631e2843077f9be197">slist_insert_before</a></div><div class="ttdeci">#define slist_insert_before(slist, posptr, nodeptr)</div><div class="ttdoc">Inserts a node before a specified position in a circular singly linked list.</div><div class="ttdef"><b>Definition:</b> <a href="slist_8h_source.html#l00462">slist.h:462</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slist</td><td>A pointer to the head of the circular singly linked list. </td></tr>
    <tr><td class="paramname">posptr</td><td>A pointer to the node before which the new node will be inserted. </td></tr>
    <tr><td class="paramname">nodeptr</td><td>A pointer to the new node to be inserted into the list. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="slist_8h_source.html#l00462">462</a> of file <a class="el" href="slist_8h_source.html">slist.h</a>.</p>

</div>
</div>
<a id="a9ede917be2b8cfef71f4084a40cedebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ede917be2b8cfef71f4084a40cedebc">&#9670;&nbsp;</a></span>slist_next</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define slist_next</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">slist, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    (((<a class="el" href="structslist__node__t.html">slist_node_t</a>*)(node))-&gt;next)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro to obtain the next node in a circular singly linked list. </p>
<p>This macro is used to access the next node of a given node in a circular singly linked list. It retrieves the 'next' pointer of the specified node (<code>node</code>), which points to the following node in the list. In a circular singly linked list, each node contains a pointer to the next node, forming a circular structure. The head node of the list also acts as a node in the list, pointing to the first data-containing node or to itself if the list is empty.</p>
<p>Usage: </p><div class="fragment"><div class="line"><a class="code" href="structslist__node__t.html">slist_node_t</a> *head = create_list(); <span class="comment">// Create and initialize the list</span></div>
<div class="line"><a class="code" href="structslist__node__t.html">slist_node_t</a> *current = head-&gt;<a class="code" href="structslist__node__t.html#acde7555eca71d1f823fbaf6f6a1f4670">next</a>; <span class="comment">// Start with the first node</span></div>
<div class="line"><span class="keywordflow">while</span> (current != head) {           <span class="comment">// Iterate until the list loops back to the head</span></div>
<div class="line">    <span class="comment">// Process the current node</span></div>
<div class="line">    current = <a class="code" href="slist_8h.html#a9ede917be2b8cfef71f4084a40cedebc">slist_next</a>(head, current);</div>
<div class="line">}</div>
<div class="ttc" id="astructslist__node__t_html_acde7555eca71d1f823fbaf6f6a1f4670"><div class="ttname"><a href="structslist__node__t.html#acde7555eca71d1f823fbaf6f6a1f4670">slist_node_t::next</a></div><div class="ttdeci">slist_node_t * next</div><div class="ttdef"><b>Definition:</b> <a href="slist_8h_source.html#l00556">slist.h:556</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slist</td><td>A pointer to the head of the circular singly linked list. </td></tr>
    <tr><td class="paramname">node</td><td>A pointer to the current node in the list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the next node in the list. </dd></dl>

<p class="definition">Definition at line <a class="el" href="slist_8h_source.html#l00109">109</a> of file <a class="el" href="slist_8h_source.html">slist.h</a>.</p>

</div>
</div>
<a id="a716336a5121f9dd051810d65a356c16c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a716336a5121f9dd051810d65a356c16c">&#9670;&nbsp;</a></span>SLIST_NODE_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SLIST_NODE_TYPE&#160;&#160;&#160;<a class="el" href="structslist__node__t.html">slist_node_t</a> slist_node</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="slist_8h_source.html#l00084">84</a> of file <a class="el" href="slist_8h_source.html">slist.h</a>.</p>

</div>
</div>
<a id="a264d4c34b7aadd955a0e307beddcafa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a264d4c34b7aadd955a0e307beddcafa3">&#9670;&nbsp;</a></span>slist_pop_back</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define slist_pop_back</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">slist</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">do</span>{                                                  \</div>
<div class="line">        slist_prev_prev(slist,slist)-&gt;next = (slist);    \</div>
<div class="line">    }<span class="keywordflow">while</span>(0)</div>
</div><!-- fragment -->
<p>Removes the last element from a circular singly linked list. </p>
<p>This macro removes the last element in the circular singly linked list. It locates the node that is two positions behind the head node (which is effectively the last node) using <code>slist_prev_prev(slist, slist)</code>, and then sets its 'next' pointer to point to the head node (<code>slist</code>). This operation removes the last node from the list.</p>
<p>Since this operation requires finding the second-to-last node, it involves traversing almost the entire list, which makes it less efficient, particularly for longer lists. The macro assumes that the list contains at least one element other than the head node. Users should check that the list is not empty before performing this operation to avoid undefined behavior.</p>
<p>Usage: </p><div class="fragment"><div class="line"><a class="code" href="structslist__node__t.html">slist_t</a> mylist;</div>
<div class="line"><a class="code" href="slist_8h.html#aeadaebf6d4d904d4b7244643352f4850">slist_init</a>(&amp;mylist);</div>
<div class="line"><span class="comment">// Add elements to the list</span></div>
<div class="line"><span class="keywordflow">if</span> (!<a class="code" href="slist_8h.html#a6b02a2ed9d13f16f44b09ead8135f34f">slist_empty</a>(&amp;mylist)) {</div>
<div class="line">    <a class="code" href="slist_8h.html#a264d4c34b7aadd955a0e307beddcafa3">slist_pop_back</a>(&amp;mylist);</div>
<div class="line">    <span class="comment">// The last node is now removed from &#39;mylist&#39;</span></div>
<div class="line">}</div>
<div class="ttc" id="aslist_8h_html_a264d4c34b7aadd955a0e307beddcafa3"><div class="ttname"><a href="slist_8h.html#a264d4c34b7aadd955a0e307beddcafa3">slist_pop_back</a></div><div class="ttdeci">#define slist_pop_back(slist)</div><div class="ttdoc">Removes the last element from a circular singly linked list.</div><div class="ttdef"><b>Definition:</b> <a href="slist_8h_source.html#l00736">slist.h:736</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slist</td><td>A pointer to the head of the circular singly linked list. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="slist_8h_source.html#l00736">736</a> of file <a class="el" href="slist_8h_source.html">slist.h</a>.</p>

</div>
</div>
<a id="aac357be3f459cf0145048e58f0e8aef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac357be3f459cf0145048e58f0e8aef8">&#9670;&nbsp;</a></span>slist_pop_front</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define slist_pop_front</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">slist</td><td>)</td>
          <td>&#160;&#160;&#160;    do{(slist)-&gt;next = (slist)-&gt;next-&gt;next;}while(0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the first element from a circular singly linked list. </p>
<p>This macro removes the first element in the circular singly linked list. It does this by setting the 'next' pointer of the head node (<code>slist</code>) to point to the second node in the list, effectively removing the first node from the list. This operation is efficient as it requires only a modification of the head node's 'next' pointer.</p>
<p>It is important to ensure that the list is not empty before calling this macro. If the list is empty (i.e., <code>slist-&gt;next</code> is <code>slist</code>), calling <code>slist_pop_front</code> will have no effect. Users should also handle memory management for the removed node if it was dynamically allocated. This macro only removes the node from the list structure; it does not free the memory associated with the node.</p>
<p>Usage: </p><div class="fragment"><div class="line"><a class="code" href="structslist__node__t.html">slist_node_t</a> mylist;</div>
<div class="line"><a class="code" href="slist_8h.html#aeadaebf6d4d904d4b7244643352f4850">slist_init</a>(&amp;mylist);</div>
<div class="line"><span class="comment">// Add elements to the list</span></div>
<div class="line"><span class="keywordflow">if</span> (!<a class="code" href="slist_8h.html#a6b02a2ed9d13f16f44b09ead8135f34f">slist_empty</a>(&amp;mylist)) {</div>
<div class="line">    <a class="code" href="slist_8h.html#aac357be3f459cf0145048e58f0e8aef8">slist_pop_front</a>(&amp;mylist);</div>
<div class="line">    <span class="comment">// The first node is now removed from &#39;mylist&#39;</span></div>
<div class="line">}</div>
<div class="ttc" id="aslist_8h_html_aac357be3f459cf0145048e58f0e8aef8"><div class="ttname"><a href="slist_8h.html#aac357be3f459cf0145048e58f0e8aef8">slist_pop_front</a></div><div class="ttdeci">#define slist_pop_front(slist)</div><div class="ttdoc">Removes the first element from a circular singly linked list.</div><div class="ttdef"><b>Definition:</b> <a href="slist_8h_source.html#l00355">slist.h:355</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slist</td><td>A pointer to the head of the circular singly linked list. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="slist_8h_source.html#l00355">355</a> of file <a class="el" href="slist_8h_source.html">slist.h</a>.</p>

</div>
</div>
<a id="a08aa73f25c13159c8f4774d2c5d77262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08aa73f25c13159c8f4774d2c5d77262">&#9670;&nbsp;</a></span>slist_push_back</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define slist_push_back</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">slist, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node_to_add&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">do</span> { \</div>
<div class="line">        ((<a class="code" href="structslist__node__t.html">slist_node_t</a>*)(node_to_add))-&gt;next = <a class="code" href="slist_8h.html#a41421643834ad4e06e0d41811c105221">slist_back</a>(slist); \</div>
<div class="line">        ((<a class="code" href="structslist__node__t.html">slist_node_t</a>*)(node_to_add))-&gt;next-&gt;<a class="code" href="structslist__node__t.html#acde7555eca71d1f823fbaf6f6a1f4670">next</a> = ((<a class="code" href="structslist__node__t.html">slist_node_t</a>*)(node_to_add)); \</div>
<div class="line">        ((<a class="code" href="structslist__node__t.html">slist_node_t</a>*)(node_to_add))-&gt;next = <a class="code" href="slist_8h.html#a4a55ae00593db3acc4726b9cf6bdfe98">slist_end</a>(slist);\</div>
<div class="line">    }<span class="keywordflow">while</span>(0)</div>
<div class="ttc" id="aslist_8h_html_a41421643834ad4e06e0d41811c105221"><div class="ttname"><a href="slist_8h.html#a41421643834ad4e06e0d41811c105221">slist_back</a></div><div class="ttdeci">slist_node_t * slist_back(slist_t *slist)</div><div class="ttdoc">Returns the last node in a circular singly linked list.</div><div class="ttdef"><b>Definition:</b> <a href="slist_8c_source.html#l00071">slist.c:71</a></div></div>
</div><!-- fragment -->
<p>Inserts an element at the end of a circular singly linked list. </p>
<p>This macro inserts a new node (<code>node_to_add</code>) at the end of the circular singly linked list. It first finds the current last node in the list using <code>slist_back(slist)</code>, which traverses the entire list. Once the last node is identified, the macro sets the 'next' pointer of this node to <code>node_to_add</code>, and then adjusts the 'next' pointer of <code>node_to_add</code> to point to the head of the list (<code>slist</code>), maintaining the circular nature of the list.</p>
<p>This operation requires traversing the entire list to find the last node, which has a linear time complexity with respect to the number of elements in the list. Users should ensure that <code>node_to_add</code> is properly allocated and initialized before using this macro.</p>
<p>Usage: </p><div class="fragment"><div class="line"><a class="code" href="structslist__node__t.html">slist_node_t</a> mylist;</div>
<div class="line"><a class="code" href="slist_8h.html#aeadaebf6d4d904d4b7244643352f4850">slist_init</a>(&amp;mylist);</div>
<div class="line"><a class="code" href="structslist__node__t.html">slist_node_t</a> *new_node = create_node(data); <span class="comment">// Assume create_node allocates and initializes a new node</span></div>
<div class="line"><a class="code" href="slist_8h.html#a08aa73f25c13159c8f4774d2c5d77262">slist_push_back</a>(&amp;mylist, new_node);</div>
<div class="line"><span class="comment">// Now &#39;new_node&#39; is the last element of &#39;mylist&#39;</span></div>
<div class="ttc" id="aslist_8h_html_a08aa73f25c13159c8f4774d2c5d77262"><div class="ttname"><a href="slist_8h.html#a08aa73f25c13159c8f4774d2c5d77262">slist_push_back</a></div><div class="ttdeci">#define slist_push_back(slist, node_to_add)</div><div class="ttdoc">Inserts an element at the end of a circular singly linked list.</div><div class="ttdef"><b>Definition:</b> <a href="slist_8h_source.html#l00386">slist.h:386</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slist</td><td>A pointer to the head of the circular singly linked list. </td></tr>
    <tr><td class="paramname">node_to_add</td><td>A pointer to the node to be added to the end of the list. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="slist_8h_source.html#l00386">386</a> of file <a class="el" href="slist_8h_source.html">slist.h</a>.</p>

</div>
</div>
<a id="af8ecf83b22259960a0638a95f26c2c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8ecf83b22259960a0638a95f26c2c1a">&#9670;&nbsp;</a></span>slist_push_front</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define slist_push_front</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">slist, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node_to_add&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">do</span>{ \</div>
<div class="line">        ((<a class="code" href="structslist__node__t.html">slist_node_t</a>*)(node_to_add))-&gt;next = (slist)-&gt;next; \</div>
<div class="line">        (slist)-&gt;next=((<a class="code" href="structslist__node__t.html">slist_node_t</a>*)(node_to_add)); \</div>
<div class="line">    }<span class="keywordflow">while</span>(0);</div>
</div><!-- fragment -->
<p>Inserts an element at the beginning of a circular singly linked list. </p>
<p>This macro inserts a new node (<code>node_to_add</code>) at the beginning of the circular singly linked list, right after the head node. The insertion is achieved by setting the 'next' pointer of <code>node_to_add</code> to the current first element of the list, and then updating the 'next' pointer of the head node (<code>slist</code>) to point to <code>node_to_add</code>. After the insertion, <code>node_to_add</code> becomes the new first element in the list.</p>
<p>This operation is efficient as it does not require traversing the list and directly modifies the necessary pointers to insert the new node. It is important to ensure that <code>node_to_add</code> is properly allocated and initialized before using this macro.</p>
<p>Usage: </p><div class="fragment"><div class="line"><a class="code" href="structslist__node__t.html">slist_node_t</a> mylist;</div>
<div class="line"><a class="code" href="slist_8h.html#aeadaebf6d4d904d4b7244643352f4850">slist_init</a>(&amp;mylist);</div>
<div class="line"><a class="code" href="structslist__node__t.html">slist_node_t</a> *new_node = create_node(data); <span class="comment">// Assume create_node allocates and initializes a new node</span></div>
<div class="line"><a class="code" href="slist_8h.html#af8ecf83b22259960a0638a95f26c2c1a">slist_push_front</a>(&amp;mylist, new_node);</div>
<div class="line"><span class="comment">// Now &#39;new_node&#39; is the first element of &#39;mylist&#39;</span></div>
<div class="ttc" id="aslist_8h_html_af8ecf83b22259960a0638a95f26c2c1a"><div class="ttname"><a href="slist_8h.html#af8ecf83b22259960a0638a95f26c2c1a">slist_push_front</a></div><div class="ttdeci">#define slist_push_front(slist, node_to_add)</div><div class="ttdoc">Inserts an element at the beginning of a circular singly linked list.</div><div class="ttdef"><b>Definition:</b> <a href="slist_8h_source.html#l00321">slist.h:321</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slist</td><td>A pointer to the head of the circular singly linked list. </td></tr>
    <tr><td class="paramname">node_to_add</td><td>A pointer to the node to be added to the beginning of the list. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="slist_8h_source.html#l00321">321</a> of file <a class="el" href="slist_8h_source.html">slist.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a807626e58194903cd491ab5b3aa82f9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a807626e58194903cd491ab5b3aa82f9c">&#9670;&nbsp;</a></span>slist_node_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structslist__node__t.html">slist_node_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for the structure representing a node in a circular singly linked list. </p>

<p class="definition">Definition at line <a class="el" href="slist_8h_source.html#l00001">1</a> of file <a class="el" href="slist_8h_source.html">slist.h</a>.</p>

</div>
</div>
<a id="ac626c3ba7de6d820620343dfc50fd279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac626c3ba7de6d820620343dfc50fd279">&#9670;&nbsp;</a></span>slist_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="slist_8h.html#ac626c3ba7de6d820620343dfc50fd279">slist_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for the circular singly linked list. </p>
<p>List instance is also a member of the list</p>
<p>This typedef is used to define a type for the circular singly linked list. It establishes <code><a class="el" href="structslist__node__t.html" title="Structure representing a node in a circular singly linked list.">slist_node_t</a></code> as the type for the head of the list. In a circular singly linked list defined by this typedef, the head node itself is a member of the list, pointing to the first data-containing node or back to itself if the list is empty. This setup simplifies certain list operations by providing a consistent starting point for list traversal and manipulation.</p>
<p>Usage: </p><div class="fragment"><div class="line"><a class="code" href="structslist__node__t.html">slist_t</a> mylist; <span class="comment">// Declare a list</span></div>
<div class="line"><a class="code" href="slist_8h.html#aeadaebf6d4d904d4b7244643352f4850">slist_init</a>(&amp;mylist); <span class="comment">// Initialize the list</span></div>
<div class="line"><span class="comment">// The list can now be used for various operations</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="slist_8h_source.html#l00576">576</a> of file <a class="el" href="slist_8h_source.html">slist.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a41421643834ad4e06e0d41811c105221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41421643834ad4e06e0d41811c105221">&#9670;&nbsp;</a></span>slist_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structslist__node__t.html">slist_node_t</a>* slist_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="slist_8h.html#ac626c3ba7de6d820620343dfc50fd279">slist_t</a> *&#160;</td>
          <td class="paramname"><em>slist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the last node in a circular singly linked list. </p>
<p>This function searches for the last node in a circular singly linked list. It starts from the end of the list, which is the head node itself (represented by <code><a class="el" href="slist_8h.html#a4a55ae00593db3acc4726b9cf6bdfe98" title="Returns an iterator to the past-the-end element in a circular singly linked list.">slist_end(slist)</a></code>), and iterates through the list until it finds a node whose 'next' pointer points back to the head node. This node is identified as the last node in the list.</p>
<p>This approach is necessary because the list is singly linked and does not have direct pointers to previous nodes. The function is useful for operations that require access to the last element of the list, such as appending elements or performing certain modifications.</p>
<dl class="section note"><dt>Note</dt><dd>The function assumes that the list is properly initialized. If the list is empty, the function will return the head node itself. The function has linear time complexity, as it may need to traverse the entire list to find the last node.</dd></dl>
<p>Usage: </p><div class="fragment"><div class="line"><a class="code" href="structslist__node__t.html">slist_t</a> mylist;</div>
<div class="line"><a class="code" href="slist_8h.html#aeadaebf6d4d904d4b7244643352f4850">slist_init</a>(&amp;mylist);</div>
<div class="line"><span class="comment">// Add elements to the list</span></div>
<div class="line"><a class="code" href="structslist__node__t.html">slist_node_t</a> *last_node = <a class="code" href="slist_8c.html#a41421643834ad4e06e0d41811c105221">slist_back</a>(&amp;mylist);</div>
<div class="line"><span class="keywordflow">if</span> (last_node != &amp;mylist) {</div>
<div class="line">    <span class="comment">// The list is not empty, and &#39;last_node&#39; is the last node in the list</span></div>
<div class="line">}</div>
<div class="ttc" id="aslist_8c_html_a41421643834ad4e06e0d41811c105221"><div class="ttname"><a href="slist_8c.html#a41421643834ad4e06e0d41811c105221">slist_back</a></div><div class="ttdeci">slist_node_t * slist_back(slist_t *slist)</div><div class="ttdoc">Returns the last node in a circular singly linked list.</div><div class="ttdef"><b>Definition:</b> <a href="slist_8c_source.html#l00071">slist.c:71</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slist</td><td>A pointer to the head of the circular singly linked list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the last node in the list, or the head node itself if the list is empty. </dd></dl>

<p class="definition">Definition at line <a class="el" href="slist_8c_source.html#l00071">71</a> of file <a class="el" href="slist_8c_source.html">slist.c</a>.</p>

</div>
</div>
<a id="a50bb2ab18efd8562fbc4882346d74f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50bb2ab18efd8562fbc4882346d74f2c">&#9670;&nbsp;</a></span>slist_find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structslist__node__t.html">slist_node_t</a>* slist_find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="slist_8h.html#ac626c3ba7de6d820620343dfc50fd279">slist_t</a> *&#160;</td>
          <td class="paramname"><em>slist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches for a specific node in a circular singly linked list. </p>
<p>This function iterates through the circular singly linked list to find a specified node (<code>node</code>). The search is conducted by comparing each node's address in the list with the address of <code>node</code>. If the specified node is found in the list, the function returns a pointer to that node; otherwise, it returns NULL.</p>
<p>The search uses the <code>slist_foreach</code> macro to traverse each node in the list. This function is useful for verifying whether a specific node is present in the list and for operations that depend on locating a particular node within the list.</p>
<dl class="section note"><dt>Note</dt><dd>The function runs in linear time complexity with respect to the number of elements in the list. It is important to ensure that the list is properly initialized before using this function.</dd></dl>
<p>Usage: </p><div class="fragment"><div class="line"><a class="code" href="structslist__node__t.html">slist_t</a> mylist;</div>
<div class="line"><a class="code" href="slist_8h.html#aeadaebf6d4d904d4b7244643352f4850">slist_init</a>(&amp;mylist);</div>
<div class="line"><span class="comment">// Add elements to the list</span></div>
<div class="line"><a class="code" href="structslist__node__t.html">slist_node_t</a> *search_node = create_node(data); <span class="comment">// Assume create_node allocates and initializes a new node</span></div>
<div class="line"><a class="code" href="slist_8h.html#a08aa73f25c13159c8f4774d2c5d77262">slist_push_back</a>(&amp;mylist, search_node);</div>
<div class="line"><span class="comment">// Now search for the node</span></div>
<div class="line"><a class="code" href="structslist__node__t.html">slist_node_t</a> *found_node = <a class="code" href="slist_8c.html#a50bb2ab18efd8562fbc4882346d74f2c">slist_find</a>(&amp;mylist, search_node);</div>
<div class="line"><span class="keywordflow">if</span> (found_node) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;Node found in the list\n&quot;</span>);</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    printf(<span class="stringliteral">&quot;Node not found in the list\n&quot;</span>);</div>
<div class="line">}</div>
<div class="ttc" id="aslist_8c_html_a50bb2ab18efd8562fbc4882346d74f2c"><div class="ttname"><a href="slist_8c.html#a50bb2ab18efd8562fbc4882346d74f2c">slist_find</a></div><div class="ttdeci">slist_node_t * slist_find(slist_t *slist, void *node)</div><div class="ttdoc">Searches for a specific node in a circular singly linked list.</div><div class="ttdef"><b>Definition:</b> <a href="slist_8c_source.html#l00056">slist.c:56</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slist</td><td>A pointer to the head of the circular singly linked list. </td></tr>
    <tr><td class="paramname">node</td><td>The node to search for in the list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the node if it exists in the list, NULL otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="slist_8c_source.html#l00056">56</a> of file <a class="el" href="slist_8c_source.html">slist.c</a>.</p>

</div>
</div>
<a id="a251765371febfc140be13cb5b785267d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a251765371febfc140be13cb5b785267d">&#9670;&nbsp;</a></span>slist_prev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structslist__node__t.html">slist_node_t</a>* slist_prev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="slist_8h.html#ac626c3ba7de6d820620343dfc50fd279">slist_t</a> *&#160;</td>
          <td class="paramname"><em>slist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>existing_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the previous node in a circular singly linked list. </p>
<p>This function searches for the node that precedes a specified node (<code>node</code>) in a circular singly linked list. Since the list is singly linked, the function traverses the list starting from the specified node and continues until it loops back to the same node. The node immediately before this loop-back is the predecessor of the given node.</p>
<p>This traversal is necessary due to the singly linked nature of the list, as there are no direct pointers to previous nodes. The function is useful for operations that require knowledge of a node's predecessor, such as certain insertion or deletion operations.</p>
<dl class="section note"><dt>Note</dt><dd>The function assumes that both the list and the node are properly initialized. If the node is not part of the list, the behavior is undefined. This function has a linear time complexity with respect to the number of elements in the list.</dd></dl>
<p>Usage: </p><div class="fragment"><div class="line"><a class="code" href="structslist__node__t.html">slist_t</a> mylist;</div>
<div class="line"><a class="code" href="slist_8h.html#aeadaebf6d4d904d4b7244643352f4850">slist_init</a>(&amp;mylist);</div>
<div class="line"><span class="comment">// Add elements to the list</span></div>
<div class="line"><a class="code" href="structslist__node__t.html">slist_node_t</a> *node = find_node(mylist, some_criteria); <span class="comment">// Assume find_node returns a valid node</span></div>
<div class="line"><a class="code" href="structslist__node__t.html">slist_node_t</a> *prev_node = <a class="code" href="slist_8c.html#ac3af93396add2d021f0d46add5282a5c">slist_prev</a>(&amp;mylist, node);</div>
<div class="line"><span class="keywordflow">if</span> (prev_node) {</div>
<div class="line">    <span class="comment">// &#39;prev_node&#39; is the predecessor of &#39;node&#39;</span></div>
<div class="line">}</div>
<div class="ttc" id="aslist_8c_html_ac3af93396add2d021f0d46add5282a5c"><div class="ttname"><a href="slist_8c.html#ac3af93396add2d021f0d46add5282a5c">slist_prev</a></div><div class="ttdeci">slist_node_t * slist_prev(slist_t *slist, void *node)</div><div class="ttdoc">Finds the previous node in a circular singly linked list.</div><div class="ttdef"><b>Definition:</b> <a href="slist_8c_source.html#l00100">slist.c:100</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slist</td><td>A pointer to the head of the circular singly linked list. </td></tr>
    <tr><td class="paramname">node</td><td>A pointer to the node whose predecessor is to be found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the predecessor of the specified node, or NULL if the node is the head of the list. </dd></dl>

<p class="definition">Definition at line <a class="el" href="slist_8c_source.html#l00100">100</a> of file <a class="el" href="slist_8c_source.html">slist.c</a>.</p>

</div>
</div>
<a id="ab2b4d20ae442d1ad98748fafae052c32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2b4d20ae442d1ad98748fafae052c32">&#9670;&nbsp;</a></span>slist_prev_prev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structslist__node__t.html">slist_node_t</a>* slist_prev_prev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="slist_8h.html#ac626c3ba7de6d820620343dfc50fd279">slist_t</a> *&#160;</td>
          <td class="paramname"><em>slist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the node two steps behind a specified node in a circular singly linked list. </p>
<p>This function searches for the node that is two positions before a specified node (<code>node</code>) in a circular singly linked list. It traverses the list, checking for the node whose 'next' node's 'next' pointer equals the specified node. If the specified node is at the beginning of the list, or the list does not contain enough elements, the function returns the list node itself, which is a well-defined behavior for this list structure.</p>
<p>This function is useful in operations where the node two steps behind a given node needs to be identified, such as certain deletion operations. Due to the singly linked nature of the list, the function iterates through the list to find the appropriate node.</p>
<dl class="section note"><dt>Note</dt><dd>This function has a linear time complexity with respect to the number of elements in the list. It is important to ensure that the list is properly initialized and the node is a part of the list.</dd></dl>
<p>Usage: </p><div class="fragment"><div class="line"><a class="code" href="structslist__node__t.html">slist_t</a> mylist;</div>
<div class="line"><a class="code" href="slist_8h.html#aeadaebf6d4d904d4b7244643352f4850">slist_init</a>(&amp;mylist);</div>
<div class="line"><span class="comment">// Add elements to the list</span></div>
<div class="line"><a class="code" href="structslist__node__t.html">slist_node_t</a> *node = find_node(mylist, some_criteria); <span class="comment">// Assume find_node returns a valid node</span></div>
<div class="line"><a class="code" href="structslist__node__t.html">slist_node_t</a> *prev_prev_node = <a class="code" href="slist_8c.html#ab2b4d20ae442d1ad98748fafae052c32">slist_prev_prev</a>(&amp;mylist, node);</div>
<div class="line"><span class="comment">// &#39;prev_prev_node&#39; is two nodes behind &#39;node&#39;, or the list node itself if not enough elements</span></div>
<div class="ttc" id="aslist_8c_html_ab2b4d20ae442d1ad98748fafae052c32"><div class="ttname"><a href="slist_8c.html#ab2b4d20ae442d1ad98748fafae052c32">slist_prev_prev</a></div><div class="ttdeci">slist_node_t * slist_prev_prev(slist_t *slist, void *node)</div><div class="ttdoc">Finds the node two steps behind a specified node in a circular singly linked list.</div><div class="ttdef"><b>Definition:</b> <a href="slist_8c_source.html#l00085">slist.c:85</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slist</td><td>A pointer to the head of the circular singly linked list. </td></tr>
    <tr><td class="paramname">node</td><td>A pointer to the node whose two-step predecessor is to be found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the node two positions before the specified node, or the list node itself if such a node does not exist. </dd></dl>

<p class="definition">Definition at line <a class="el" href="slist_8c_source.html#l00085">85</a> of file <a class="el" href="slist_8c_source.html">slist.c</a>.</p>

</div>
</div>
<a id="a382fcc84d290b85188e910d4d65b3e13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a382fcc84d290b85188e910d4d65b3e13">&#9670;&nbsp;</a></span>slist_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t slist_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="slist_8h.html#ac626c3ba7de6d820620343dfc50fd279">slist_t</a> *&#160;</td>
          <td class="paramname"><em>slist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of nodes in a circular singly linked list. </p>
<p>This function calculates and returns the number of elements (nodes) present in a circular singly linked list, excluding the head node itself. It traverses the list starting from the first element after the head node and counts each node until it reaches the head node again.</p>
<p>The traversal makes use of the <code>slist_foreach</code> macro, which iterates over each node in the list. The function is useful for determining the size of the list for various operations such as allocation, serialization, or applying algorithms that depend on the number of elements.</p>
<dl class="section note"><dt>Note</dt><dd>The function assumes that the list is properly initialized. An uninitialized or improperly formed list might lead to undefined behavior. The function runs in linear time complexity, as it traverses each element of the list.</dd></dl>
<p>Usage: </p><div class="fragment"><div class="line"><a class="code" href="structslist__node__t.html">slist_t</a> mylist;</div>
<div class="line"><a class="code" href="slist_8h.html#aeadaebf6d4d904d4b7244643352f4850">slist_init</a>(&amp;mylist);</div>
<div class="line"><span class="comment">// Add elements to the list</span></div>
<div class="line"><span class="keywordtype">size_t</span> list_size = <a class="code" href="slist_8c.html#a382fcc84d290b85188e910d4d65b3e13">slist_size</a>(&amp;mylist);</div>
<div class="line">printf(<span class="stringliteral">&quot;List contains %zu elements\n&quot;</span>, list_size);</div>
<div class="ttc" id="aslist_8c_html_a382fcc84d290b85188e910d4d65b3e13"><div class="ttname"><a href="slist_8c.html#a382fcc84d290b85188e910d4d65b3e13">slist_size</a></div><div class="ttdeci">size_t slist_size(slist_t *slist)</div><div class="ttdoc">Counts the number of nodes in a circular singly linked list.</div><div class="ttdef"><b>Definition:</b> <a href="slist_8c_source.html#l00113">slist.c:113</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slist</td><td>A pointer to the head of the circular singly linked list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the list, excluding the head node itself. </dd></dl>

<p class="definition">Definition at line <a class="el" href="slist_8c_source.html#l00113">113</a> of file <a class="el" href="slist_8c_source.html">slist.c</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_31203ee4bd5a40761b5a1bacfafff785.html">myos</a></li><li class="navelem"><a class="el" href="dir_ab5651bb529f81acb9f66f76269f425b.html">lib</a></li><li class="navelem"><a class="el" href="slist_8h.html">slist.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
