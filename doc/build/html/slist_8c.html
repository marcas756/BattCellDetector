<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MyOs: myos/lib/slist.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MyOs
   &#160;<span id="projectnumber">0.0.0</span>
   </div>
   <div id="projectbrief">MyOs based on Contiki-Os concepts for memory constrained microcontrollers.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('slist_8c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">slist.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Circular singly linked list.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &quot;<a class="el" href="slist_8h_source.html">slist.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for slist.c:</div>
<div class="dyncontent">
<div class="center"><img src="slist_8c__incl.png" border="0" usemap="#amyos_2lib_2slist_8c" alt=""/></div>
<map name="amyos_2lib_2slist_8c" id="amyos_2lib_2slist_8c">
<area shape="rect" title="Circular singly linked list." alt="" coords="26,5,146,32"/>
<area shape="rect" title=" " alt="" coords="5,80,76,107"/>
<area shape="rect" href="slist_8h.html" title="Circular singly linked list." alt="" coords="101,80,162,107"/>
<area shape="rect" title=" " alt="" coords="42,155,117,181"/>
<area shape="rect" title=" " alt="" coords="141,155,223,181"/>
</map>
</div>
</div>
<p><a href="slist_8c_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a50bb2ab18efd8562fbc4882346d74f2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structslist__node__t.html">slist_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8c.html#a50bb2ab18efd8562fbc4882346d74f2c">slist_find</a> (<a class="el" href="slist_8h.html#ac626c3ba7de6d820620343dfc50fd279">slist_t</a> *slist, void *node)</td></tr>
<tr class="memdesc:a50bb2ab18efd8562fbc4882346d74f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for a specific node in a circular singly linked list.  <a href="slist_8c.html#a50bb2ab18efd8562fbc4882346d74f2c">More...</a><br /></td></tr>
<tr class="separator:a50bb2ab18efd8562fbc4882346d74f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41421643834ad4e06e0d41811c105221"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structslist__node__t.html">slist_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8c.html#a41421643834ad4e06e0d41811c105221">slist_back</a> (<a class="el" href="slist_8h.html#ac626c3ba7de6d820620343dfc50fd279">slist_t</a> *slist)</td></tr>
<tr class="memdesc:a41421643834ad4e06e0d41811c105221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last node in a circular singly linked list.  <a href="slist_8c.html#a41421643834ad4e06e0d41811c105221">More...</a><br /></td></tr>
<tr class="separator:a41421643834ad4e06e0d41811c105221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b4d20ae442d1ad98748fafae052c32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structslist__node__t.html">slist_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8c.html#ab2b4d20ae442d1ad98748fafae052c32">slist_prev_prev</a> (<a class="el" href="slist_8h.html#ac626c3ba7de6d820620343dfc50fd279">slist_t</a> *slist, void *node)</td></tr>
<tr class="memdesc:ab2b4d20ae442d1ad98748fafae052c32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the node two steps behind a specified node in a circular singly linked list.  <a href="slist_8c.html#ab2b4d20ae442d1ad98748fafae052c32">More...</a><br /></td></tr>
<tr class="separator:ab2b4d20ae442d1ad98748fafae052c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3af93396add2d021f0d46add5282a5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structslist__node__t.html">slist_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8c.html#ac3af93396add2d021f0d46add5282a5c">slist_prev</a> (<a class="el" href="slist_8h.html#ac626c3ba7de6d820620343dfc50fd279">slist_t</a> *slist, void *node)</td></tr>
<tr class="memdesc:ac3af93396add2d021f0d46add5282a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the previous node in a circular singly linked list.  <a href="slist_8c.html#ac3af93396add2d021f0d46add5282a5c">More...</a><br /></td></tr>
<tr class="separator:ac3af93396add2d021f0d46add5282a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a382fcc84d290b85188e910d4d65b3e13"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slist_8c.html#a382fcc84d290b85188e910d4d65b3e13">slist_size</a> (<a class="el" href="slist_8h.html#ac626c3ba7de6d820620343dfc50fd279">slist_t</a> *slist)</td></tr>
<tr class="memdesc:a382fcc84d290b85188e910d4d65b3e13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of nodes in a circular singly linked list.  <a href="slist_8c.html#a382fcc84d290b85188e910d4d65b3e13">More...</a><br /></td></tr>
<tr class="separator:a382fcc84d290b85188e910d4d65b3e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Circular singly linked list. </p>
<p>In computer science, a linked list is a linear collection of data elements, whose order is not given by their physical placement in memory. Instead, each element points to the next. It is a data structure consisting of a collection of nodes which together represent a sequence. In its most basic form, each node contains: data, and a reference (in other words, a link) to the next node in the sequence. This structure allows for efficient insertion or removal of elements from any position in the sequence during iteration. [<a href="https://en.wikipedia.org/wiki/Linked_list">https://en.wikipedia.org/wiki/Linked_list</a>]</p>
<p>Singly linked lists contain nodes which have a data field as well as 'next' field, which points to the next node in line of nodes. Operations that can be performed on singly linked lists include insertion, deletion and traversal. [<a href="https://en.wikipedia.org/wiki/Linked_list#Singly_linked_list">https://en.wikipedia.org/wiki/Linked_list#Singly_linked_list</a>]</p>
<p>In the last node of a list, the link field often contains a null reference, a special value is used to indicate the lack of further nodes. A less common convention is to make it point to the first node of the list; in that case, the list is said to be 'circular' or 'circularly linked'; otherwise, it is said to be 'open' or 'linear'. It is a list where the last pointer points to the first node. [<a href="https://en.wikipedia.org/wiki/Linked_list#Circular_linked_list">https://en.wikipedia.org/wiki/Linked_list#Circular_linked_list</a>] </p>

<p class="definition">Definition in file <a class="el" href="slist_8c_source.html">slist.c</a>.</p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a41421643834ad4e06e0d41811c105221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41421643834ad4e06e0d41811c105221">&#9670;&nbsp;</a></span>slist_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structslist__node__t.html">slist_node_t</a>* slist_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="slist_8h.html#ac626c3ba7de6d820620343dfc50fd279">slist_t</a> *&#160;</td>
          <td class="paramname"><em>slist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the last node in a circular singly linked list. </p>
<p>This function searches for the last node in a circular singly linked list. It starts from the end of the list, which is the head node itself (represented by <code><a class="el" href="slist_8h.html#a4a55ae00593db3acc4726b9cf6bdfe98" title="Returns an iterator to the past-the-end element in a circular singly linked list.">slist_end(slist)</a></code>), and iterates through the list until it finds a node whose 'next' pointer points back to the head node. This node is identified as the last node in the list.</p>
<p>This approach is necessary because the list is singly linked and does not have direct pointers to previous nodes. The function is useful for operations that require access to the last element of the list, such as appending elements or performing certain modifications.</p>
<dl class="section note"><dt>Note</dt><dd>The function assumes that the list is properly initialized. If the list is empty, the function will return the head node itself. The function has linear time complexity, as it may need to traverse the entire list to find the last node.</dd></dl>
<p>Usage: </p><div class="fragment"><div class="line"><a class="code" href="structslist__node__t.html">slist_t</a> mylist;</div>
<div class="line"><a class="code" href="slist_8h.html#aeadaebf6d4d904d4b7244643352f4850">slist_init</a>(&amp;mylist);</div>
<div class="line"><span class="comment">// Add elements to the list</span></div>
<div class="line"><a class="code" href="structslist__node__t.html">slist_node_t</a> *last_node = <a class="code" href="slist_8c.html#a41421643834ad4e06e0d41811c105221">slist_back</a>(&amp;mylist);</div>
<div class="line"><span class="keywordflow">if</span> (last_node != &amp;mylist) {</div>
<div class="line">    <span class="comment">// The list is not empty, and &#39;last_node&#39; is the last node in the list</span></div>
<div class="line">}</div>
<div class="ttc" id="aslist_8c_html_a41421643834ad4e06e0d41811c105221"><div class="ttname"><a href="slist_8c.html#a41421643834ad4e06e0d41811c105221">slist_back</a></div><div class="ttdeci">slist_node_t * slist_back(slist_t *slist)</div><div class="ttdoc">Returns the last node in a circular singly linked list.</div><div class="ttdef"><b>Definition:</b> <a href="slist_8c_source.html#l00071">slist.c:71</a></div></div>
<div class="ttc" id="aslist_8h_html_aeadaebf6d4d904d4b7244643352f4850"><div class="ttname"><a href="slist_8h.html#aeadaebf6d4d904d4b7244643352f4850">slist_init</a></div><div class="ttdeci">#define slist_init(slist)</div><div class="ttdoc">Initializes a circular singly linked list.</div><div class="ttdef"><b>Definition:</b> <a href="slist_8h_source.html#l00134">slist.h:134</a></div></div>
<div class="ttc" id="astructslist__node__t_html"><div class="ttname"><a href="structslist__node__t.html">slist_node_t</a></div><div class="ttdoc">Structure representing a node in a circular singly linked list.</div><div class="ttdef"><b>Definition:</b> <a href="slist_8h_source.html#l00555">slist.h:555</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slist</td><td>A pointer to the head of the circular singly linked list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the last node in the list, or the head node itself if the list is empty. </dd></dl>

<p class="definition">Definition at line <a class="el" href="slist_8c_source.html#l00071">71</a> of file <a class="el" href="slist_8c_source.html">slist.c</a>.</p>

</div>
</div>
<a id="a50bb2ab18efd8562fbc4882346d74f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50bb2ab18efd8562fbc4882346d74f2c">&#9670;&nbsp;</a></span>slist_find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structslist__node__t.html">slist_node_t</a>* slist_find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="slist_8h.html#ac626c3ba7de6d820620343dfc50fd279">slist_t</a> *&#160;</td>
          <td class="paramname"><em>slist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches for a specific node in a circular singly linked list. </p>
<p>This function iterates through the circular singly linked list to find a specified node (<code>node</code>). The search is conducted by comparing each node's address in the list with the address of <code>node</code>. If the specified node is found in the list, the function returns a pointer to that node; otherwise, it returns NULL.</p>
<p>The search uses the <code>slist_foreach</code> macro to traverse each node in the list. This function is useful for verifying whether a specific node is present in the list and for operations that depend on locating a particular node within the list.</p>
<dl class="section note"><dt>Note</dt><dd>The function runs in linear time complexity with respect to the number of elements in the list. It is important to ensure that the list is properly initialized before using this function.</dd></dl>
<p>Usage: </p><div class="fragment"><div class="line"><a class="code" href="structslist__node__t.html">slist_t</a> mylist;</div>
<div class="line"><a class="code" href="slist_8h.html#aeadaebf6d4d904d4b7244643352f4850">slist_init</a>(&amp;mylist);</div>
<div class="line"><span class="comment">// Add elements to the list</span></div>
<div class="line"><a class="code" href="structslist__node__t.html">slist_node_t</a> *search_node = create_node(data); <span class="comment">// Assume create_node allocates and initializes a new node</span></div>
<div class="line"><a class="code" href="slist_8h.html#a08aa73f25c13159c8f4774d2c5d77262">slist_push_back</a>(&amp;mylist, search_node);</div>
<div class="line"><span class="comment">// Now search for the node</span></div>
<div class="line"><a class="code" href="structslist__node__t.html">slist_node_t</a> *found_node = <a class="code" href="slist_8c.html#a50bb2ab18efd8562fbc4882346d74f2c">slist_find</a>(&amp;mylist, search_node);</div>
<div class="line"><span class="keywordflow">if</span> (found_node) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;Node found in the list\n&quot;</span>);</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    printf(<span class="stringliteral">&quot;Node not found in the list\n&quot;</span>);</div>
<div class="line">}</div>
<div class="ttc" id="aslist_8c_html_a50bb2ab18efd8562fbc4882346d74f2c"><div class="ttname"><a href="slist_8c.html#a50bb2ab18efd8562fbc4882346d74f2c">slist_find</a></div><div class="ttdeci">slist_node_t * slist_find(slist_t *slist, void *node)</div><div class="ttdoc">Searches for a specific node in a circular singly linked list.</div><div class="ttdef"><b>Definition:</b> <a href="slist_8c_source.html#l00056">slist.c:56</a></div></div>
<div class="ttc" id="aslist_8h_html_a08aa73f25c13159c8f4774d2c5d77262"><div class="ttname"><a href="slist_8h.html#a08aa73f25c13159c8f4774d2c5d77262">slist_push_back</a></div><div class="ttdeci">#define slist_push_back(slist, node_to_add)</div><div class="ttdoc">Inserts an element at the end of a circular singly linked list.</div><div class="ttdef"><b>Definition:</b> <a href="slist_8h_source.html#l00386">slist.h:386</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slist</td><td>A pointer to the head of the circular singly linked list. </td></tr>
    <tr><td class="paramname">node</td><td>The node to search for in the list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the node if it exists in the list, NULL otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="slist_8c_source.html#l00056">56</a> of file <a class="el" href="slist_8c_source.html">slist.c</a>.</p>

</div>
</div>
<a id="ac3af93396add2d021f0d46add5282a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3af93396add2d021f0d46add5282a5c">&#9670;&nbsp;</a></span>slist_prev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structslist__node__t.html">slist_node_t</a>* slist_prev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="slist_8h.html#ac626c3ba7de6d820620343dfc50fd279">slist_t</a> *&#160;</td>
          <td class="paramname"><em>slist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>existing_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the previous node in a circular singly linked list. </p>
<p>This function searches for the node that precedes a specified node (<code>node</code>) in a circular singly linked list. Since the list is singly linked, the function traverses the list starting from the specified node and continues until it loops back to the same node. The node immediately before this loop-back is the predecessor of the given node.</p>
<p>This traversal is necessary due to the singly linked nature of the list, as there are no direct pointers to previous nodes. The function is useful for operations that require knowledge of a node's predecessor, such as certain insertion or deletion operations.</p>
<dl class="section note"><dt>Note</dt><dd>The function assumes that both the list and the node are properly initialized. If the node is not part of the list, the behavior is undefined. This function has a linear time complexity with respect to the number of elements in the list.</dd></dl>
<p>Usage: </p><div class="fragment"><div class="line"><a class="code" href="structslist__node__t.html">slist_t</a> mylist;</div>
<div class="line"><a class="code" href="slist_8h.html#aeadaebf6d4d904d4b7244643352f4850">slist_init</a>(&amp;mylist);</div>
<div class="line"><span class="comment">// Add elements to the list</span></div>
<div class="line"><a class="code" href="structslist__node__t.html">slist_node_t</a> *node = find_node(mylist, some_criteria); <span class="comment">// Assume find_node returns a valid node</span></div>
<div class="line"><a class="code" href="structslist__node__t.html">slist_node_t</a> *prev_node = <a class="code" href="slist_8c.html#ac3af93396add2d021f0d46add5282a5c">slist_prev</a>(&amp;mylist, node);</div>
<div class="line"><span class="keywordflow">if</span> (prev_node) {</div>
<div class="line">    <span class="comment">// &#39;prev_node&#39; is the predecessor of &#39;node&#39;</span></div>
<div class="line">}</div>
<div class="ttc" id="aslist_8c_html_ac3af93396add2d021f0d46add5282a5c"><div class="ttname"><a href="slist_8c.html#ac3af93396add2d021f0d46add5282a5c">slist_prev</a></div><div class="ttdeci">slist_node_t * slist_prev(slist_t *slist, void *node)</div><div class="ttdoc">Finds the previous node in a circular singly linked list.</div><div class="ttdef"><b>Definition:</b> <a href="slist_8c_source.html#l00100">slist.c:100</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slist</td><td>A pointer to the head of the circular singly linked list. </td></tr>
    <tr><td class="paramname">node</td><td>A pointer to the node whose predecessor is to be found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the predecessor of the specified node, or NULL if the node is the head of the list. </dd></dl>

<p class="definition">Definition at line <a class="el" href="slist_8c_source.html#l00100">100</a> of file <a class="el" href="slist_8c_source.html">slist.c</a>.</p>

</div>
</div>
<a id="ab2b4d20ae442d1ad98748fafae052c32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2b4d20ae442d1ad98748fafae052c32">&#9670;&nbsp;</a></span>slist_prev_prev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structslist__node__t.html">slist_node_t</a>* slist_prev_prev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="slist_8h.html#ac626c3ba7de6d820620343dfc50fd279">slist_t</a> *&#160;</td>
          <td class="paramname"><em>slist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the node two steps behind a specified node in a circular singly linked list. </p>
<p>This function searches for the node that is two positions before a specified node (<code>node</code>) in a circular singly linked list. It traverses the list, checking for the node whose 'next' node's 'next' pointer equals the specified node. If the specified node is at the beginning of the list, or the list does not contain enough elements, the function returns the list node itself, which is a well-defined behavior for this list structure.</p>
<p>This function is useful in operations where the node two steps behind a given node needs to be identified, such as certain deletion operations. Due to the singly linked nature of the list, the function iterates through the list to find the appropriate node.</p>
<dl class="section note"><dt>Note</dt><dd>This function has a linear time complexity with respect to the number of elements in the list. It is important to ensure that the list is properly initialized and the node is a part of the list.</dd></dl>
<p>Usage: </p><div class="fragment"><div class="line"><a class="code" href="structslist__node__t.html">slist_t</a> mylist;</div>
<div class="line"><a class="code" href="slist_8h.html#aeadaebf6d4d904d4b7244643352f4850">slist_init</a>(&amp;mylist);</div>
<div class="line"><span class="comment">// Add elements to the list</span></div>
<div class="line"><a class="code" href="structslist__node__t.html">slist_node_t</a> *node = find_node(mylist, some_criteria); <span class="comment">// Assume find_node returns a valid node</span></div>
<div class="line"><a class="code" href="structslist__node__t.html">slist_node_t</a> *prev_prev_node = <a class="code" href="slist_8c.html#ab2b4d20ae442d1ad98748fafae052c32">slist_prev_prev</a>(&amp;mylist, node);</div>
<div class="line"><span class="comment">// &#39;prev_prev_node&#39; is two nodes behind &#39;node&#39;, or the list node itself if not enough elements</span></div>
<div class="ttc" id="aslist_8c_html_ab2b4d20ae442d1ad98748fafae052c32"><div class="ttname"><a href="slist_8c.html#ab2b4d20ae442d1ad98748fafae052c32">slist_prev_prev</a></div><div class="ttdeci">slist_node_t * slist_prev_prev(slist_t *slist, void *node)</div><div class="ttdoc">Finds the node two steps behind a specified node in a circular singly linked list.</div><div class="ttdef"><b>Definition:</b> <a href="slist_8c_source.html#l00085">slist.c:85</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slist</td><td>A pointer to the head of the circular singly linked list. </td></tr>
    <tr><td class="paramname">node</td><td>A pointer to the node whose two-step predecessor is to be found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the node two positions before the specified node, or the list node itself if such a node does not exist. </dd></dl>

<p class="definition">Definition at line <a class="el" href="slist_8c_source.html#l00085">85</a> of file <a class="el" href="slist_8c_source.html">slist.c</a>.</p>

</div>
</div>
<a id="a382fcc84d290b85188e910d4d65b3e13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a382fcc84d290b85188e910d4d65b3e13">&#9670;&nbsp;</a></span>slist_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t slist_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="slist_8h.html#ac626c3ba7de6d820620343dfc50fd279">slist_t</a> *&#160;</td>
          <td class="paramname"><em>slist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of nodes in a circular singly linked list. </p>
<p>This function calculates and returns the number of elements (nodes) present in a circular singly linked list, excluding the head node itself. It traverses the list starting from the first element after the head node and counts each node until it reaches the head node again.</p>
<p>The traversal makes use of the <code>slist_foreach</code> macro, which iterates over each node in the list. The function is useful for determining the size of the list for various operations such as allocation, serialization, or applying algorithms that depend on the number of elements.</p>
<dl class="section note"><dt>Note</dt><dd>The function assumes that the list is properly initialized. An uninitialized or improperly formed list might lead to undefined behavior. The function runs in linear time complexity, as it traverses each element of the list.</dd></dl>
<p>Usage: </p><div class="fragment"><div class="line"><a class="code" href="structslist__node__t.html">slist_t</a> mylist;</div>
<div class="line"><a class="code" href="slist_8h.html#aeadaebf6d4d904d4b7244643352f4850">slist_init</a>(&amp;mylist);</div>
<div class="line"><span class="comment">// Add elements to the list</span></div>
<div class="line"><span class="keywordtype">size_t</span> list_size = <a class="code" href="slist_8c.html#a382fcc84d290b85188e910d4d65b3e13">slist_size</a>(&amp;mylist);</div>
<div class="line">printf(<span class="stringliteral">&quot;List contains %zu elements\n&quot;</span>, list_size);</div>
<div class="ttc" id="aslist_8c_html_a382fcc84d290b85188e910d4d65b3e13"><div class="ttname"><a href="slist_8c.html#a382fcc84d290b85188e910d4d65b3e13">slist_size</a></div><div class="ttdeci">size_t slist_size(slist_t *slist)</div><div class="ttdoc">Counts the number of nodes in a circular singly linked list.</div><div class="ttdef"><b>Definition:</b> <a href="slist_8c_source.html#l00113">slist.c:113</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slist</td><td>A pointer to the head of the circular singly linked list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the list, excluding the head node itself. </dd></dl>

<p class="definition">Definition at line <a class="el" href="slist_8c_source.html#l00113">113</a> of file <a class="el" href="slist_8c_source.html">slist.c</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_31203ee4bd5a40761b5a1bacfafff785.html">myos</a></li><li class="navelem"><a class="el" href="dir_ab5651bb529f81acb9f66f76269f425b.html">lib</a></li><li class="navelem"><a class="el" href="slist_8c.html">slist.c</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
