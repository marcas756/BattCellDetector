<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MyOs: myos/lib/dlist.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MyOs
   &#160;<span id="projectnumber">0.0.0</span>
   </div>
   <div id="projectbrief">MyOs based on Contiki-Os concepts for memory constrained microcontrollers.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('dlist_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">dlist.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Circular doubly linked list.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stddef.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for dlist.h:</div>
<div class="dyncontent">
<div class="center"><img src="dlist_8h__incl.png" border="0" usemap="#amyos_2lib_2dlist_8h" alt=""/></div>
<map name="amyos_2lib_2dlist_8h" id="amyos_2lib_2dlist_8h">
<area shape="rect" title="Circular doubly linked list." alt="" coords="5,5,128,32"/>
<area shape="rect" title=" " alt="" coords="29,80,104,107"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="dlist_8h__dep__incl.png" border="0" usemap="#amyos_2lib_2dlist_8hdep" alt=""/></div>
<map name="amyos_2lib_2dlist_8hdep" id="amyos_2lib_2dlist_8hdep">
<area shape="rect" title="Circular doubly linked list." alt="" coords="171,5,294,32"/>
<area shape="rect" href="dlist_8c.html" title=" " alt="" coords="96,80,217,107"/>
<area shape="rect" href="ptimer_8h.html" title=" " alt="" coords="241,80,376,107"/>
<area shape="rect" href="myos_8h.html" title=" " alt="" coords="244,155,373,181"/>
<area shape="rect" href="ctimer_8h.html" title="Callback timer implementation (ctimer)" alt="" coords="5,229,140,256"/>
<area shape="rect" href="etimer_8h.html" title=" " alt="" coords="164,229,299,256"/>
<area shape="rect" href="myos_8c.html" title=" " alt="" coords="323,229,451,256"/>
<area shape="rect" href="process_8c.html" title=" " alt="" coords="476,229,619,256"/>
<area shape="rect" href="ptimer_8c.html" title=" " alt="" coords="643,229,777,256"/>
<area shape="rect" href="uibuttons__process_8c.html" title=" " alt="" coords="801,229,1008,256"/>
<area shape="rect" href="ctimer_8c.html" title=" " alt="" coords="6,304,139,331"/>
<area shape="rect" href="etimer_8c.html" title=" " alt="" coords="164,304,299,331"/>
<area shape="rect" href="uileds__process_8c.html" title=" " alt="" coords="323,304,508,331"/>
</map>
</div>
</div>
<p><a href="dlist_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlist__node__t.html">dlist_node_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure representing a node in a circular doubly linked list.  <a href="structdlist__node__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a207dad2368bb8983a3fb2df6ca25a080"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dlist_8h.html#a207dad2368bb8983a3fb2df6ca25a080">DLIST_NODE_TYPE</a>&#160;&#160;&#160;<a class="el" href="structdlist__node__t.html">dlist_node_t</a> dlist_node</td></tr>
<tr class="memdesc:a207dad2368bb8983a3fb2df6ca25a080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to embed a list node in a structure for a circular doubly linked list.  <a href="dlist_8h.html#a207dad2368bb8983a3fb2df6ca25a080">More...</a><br /></td></tr>
<tr class="separator:a207dad2368bb8983a3fb2df6ca25a080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d22ada75e1ef9d60ebe8d580f5ea05b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dlist_8h.html#a5d22ada75e1ef9d60ebe8d580f5ea05b">dlist_next</a>(dlist,  existing_node)&#160;&#160;&#160;    (((<a class="el" href="structdlist__node__t.html">dlist_node_t</a>*)(existing_node))-&gt;next)</td></tr>
<tr class="memdesc:a5d22ada75e1ef9d60ebe8d580f5ea05b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the next node in a circular doubly linked list.  <a href="dlist_8h.html#a5d22ada75e1ef9d60ebe8d580f5ea05b">More...</a><br /></td></tr>
<tr class="separator:a5d22ada75e1ef9d60ebe8d580f5ea05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b530d7d8bc62657ffb605744bbc497"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dlist_8h.html#a79b530d7d8bc62657ffb605744bbc497">dlist_prev</a>(dlist,  existing_node)&#160;&#160;&#160;    (((<a class="el" href="structdlist__node__t.html">dlist_node_t</a>*)(existing_node))-&gt;prev)</td></tr>
<tr class="memdesc:a79b530d7d8bc62657ffb605744bbc497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the previous node in a circular doubly linked list.  <a href="dlist_8h.html#a79b530d7d8bc62657ffb605744bbc497">More...</a><br /></td></tr>
<tr class="separator:a79b530d7d8bc62657ffb605744bbc497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b88be10a7e1ecc7763abae712aa7fc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dlist_8h.html#a91b88be10a7e1ecc7763abae712aa7fc">dlist_init</a>(dlist)</td></tr>
<tr class="memdesc:a91b88be10a7e1ecc7763abae712aa7fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a circular doubly linked list.  <a href="dlist_8h.html#a91b88be10a7e1ecc7763abae712aa7fc">More...</a><br /></td></tr>
<tr class="separator:a91b88be10a7e1ecc7763abae712aa7fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4882a8fe635c6d04587830d7816473e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dlist_8h.html#aa4882a8fe635c6d04587830d7816473e">dlist_begin</a>(dlist)&#160;&#160;&#160;((dlist)-&gt;next)</td></tr>
<tr class="memdesc:aa4882a8fe635c6d04587830d7816473e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning of the list.  <a href="dlist_8h.html#aa4882a8fe635c6d04587830d7816473e">More...</a><br /></td></tr>
<tr class="separator:aa4882a8fe635c6d04587830d7816473e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f6a586785093d37647d26709d9d90c8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dlist_8h.html#a6f6a586785093d37647d26709d9d90c8">dlist_front</a>(dlist)&#160;&#160;&#160;(<a class="el" href="dlist_8h.html#aa4882a8fe635c6d04587830d7816473e">dlist_begin</a>(dlist))</td></tr>
<tr class="memdesc:a6f6a586785093d37647d26709d9d90c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the first element in a circular doubly linked list.  <a href="dlist_8h.html#a6f6a586785093d37647d26709d9d90c8">More...</a><br /></td></tr>
<tr class="separator:a6f6a586785093d37647d26709d9d90c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d3fcaf247e1020ca87d6cb65757a935"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dlist_8h.html#a6d3fcaf247e1020ca87d6cb65757a935">dlist_end</a>(dlist)&#160;&#160;&#160;(dlist)</td></tr>
<tr class="memdesc:a6d3fcaf247e1020ca87d6cb65757a935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the past-the-end element in a circular doubly linked list.  <a href="dlist_8h.html#a6d3fcaf247e1020ca87d6cb65757a935">More...</a><br /></td></tr>
<tr class="separator:a6d3fcaf247e1020ca87d6cb65757a935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d2033bf85a976df0264660e75897f4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dlist_8h.html#ad1d2033bf85a976df0264660e75897f4">dlist_back</a>(dlist)&#160;&#160;&#160;(<a class="el" href="dlist_8h.html#a79b530d7d8bc62657ffb605744bbc497">dlist_prev</a>(dlist,dlist))</td></tr>
<tr class="memdesc:ad1d2033bf85a976df0264660e75897f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last node in a circular doubly linked list.  <a href="dlist_8h.html#ad1d2033bf85a976df0264660e75897f4">More...</a><br /></td></tr>
<tr class="separator:ad1d2033bf85a976df0264660e75897f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f810c5c180e951efd3e89eca994dfb5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dlist_8h.html#a6f810c5c180e951efd3e89eca994dfb5">dlist_foreach</a>(dlist,  iterator)&#160;&#160;&#160;    for(iterator = (void*)<a class="el" href="dlist_8h.html#aa4882a8fe635c6d04587830d7816473e">dlist_begin</a>(dlist); ((<a class="el" href="structdlist__node__t.html">dlist_node_t</a>*)iterator) != <a class="el" href="dlist_8h.html#a6d3fcaf247e1020ca87d6cb65757a935">dlist_end</a>(dlist); iterator=(void*)<a class="el" href="dlist_8h.html#a5d22ada75e1ef9d60ebe8d580f5ea05b">dlist_next</a>(dlist,iterator))</td></tr>
<tr class="memdesc:a6f810c5c180e951efd3e89eca994dfb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates through all elements in a circular doubly linked list.  <a href="dlist_8h.html#a6f810c5c180e951efd3e89eca994dfb5">More...</a><br /></td></tr>
<tr class="separator:a6f810c5c180e951efd3e89eca994dfb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d6434a21efbaa32af5c6ea7778fbca"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dlist_8h.html#a32d6434a21efbaa32af5c6ea7778fbca">dlist_empty</a>(dlist)&#160;&#160;&#160;((dlist)-&gt;next==(dlist))</td></tr>
<tr class="memdesc:a32d6434a21efbaa32af5c6ea7778fbca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether a circular doubly linked list is empty.  <a href="dlist_8h.html#a32d6434a21efbaa32af5c6ea7778fbca">More...</a><br /></td></tr>
<tr class="separator:a32d6434a21efbaa32af5c6ea7778fbca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65124d2ea3f72b8fb6f511d89e74c0d1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dlist_8h.html#a65124d2ea3f72b8fb6f511d89e74c0d1">dlist_push_front</a>(dlist,  node_to_add)</td></tr>
<tr class="memdesc:a65124d2ea3f72b8fb6f511d89e74c0d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element at the beginning of a circular doubly linked list.  <a href="dlist_8h.html#a65124d2ea3f72b8fb6f511d89e74c0d1">More...</a><br /></td></tr>
<tr class="separator:a65124d2ea3f72b8fb6f511d89e74c0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab68129d82e32313b0174c636f735f80a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dlist_8h.html#ab68129d82e32313b0174c636f735f80a">dlist_pop_front</a>(dlist)</td></tr>
<tr class="memdesc:ab68129d82e32313b0174c636f735f80a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the first node in a circular doubly linked list.  <a href="dlist_8h.html#ab68129d82e32313b0174c636f735f80a">More...</a><br /></td></tr>
<tr class="separator:ab68129d82e32313b0174c636f735f80a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab234e0b85f3f015ac0419939efb4987"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dlist_8h.html#aab234e0b85f3f015ac0419939efb4987">dlist_push_back</a>(dlist,  node_to_add)</td></tr>
<tr class="memdesc:aab234e0b85f3f015ac0419939efb4987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element at the end of a circular doubly linked list.  <a href="dlist_8h.html#aab234e0b85f3f015ac0419939efb4987">More...</a><br /></td></tr>
<tr class="separator:aab234e0b85f3f015ac0419939efb4987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e6ae1179141b1425f476b5d9423b71"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dlist_8h.html#a31e6ae1179141b1425f476b5d9423b71">dlist_pop_back</a>(dlist)</td></tr>
<tr class="memdesc:a31e6ae1179141b1425f476b5d9423b71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last element from a circular doubly linked list.  <a href="dlist_8h.html#a31e6ae1179141b1425f476b5d9423b71">More...</a><br /></td></tr>
<tr class="separator:a31e6ae1179141b1425f476b5d9423b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afafccb52bd9b1129aa39c59f6f3fbcd3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dlist_8h.html#afafccb52bd9b1129aa39c59f6f3fbcd3">dlist_erase</a>(dlist,  existing_node)</td></tr>
<tr class="memdesc:afafccb52bd9b1129aa39c59f6f3fbcd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a specific node from a circular doubly linked list.  <a href="dlist_8h.html#afafccb52bd9b1129aa39c59f6f3fbcd3">More...</a><br /></td></tr>
<tr class="separator:afafccb52bd9b1129aa39c59f6f3fbcd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d504f97bec128e16205f0fa63bce82f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dlist_8h.html#a0d504f97bec128e16205f0fa63bce82f">dlist_insert_after</a>(dlist,  existing_node,  node_to_insert)</td></tr>
<tr class="memdesc:a0d504f97bec128e16205f0fa63bce82f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element after a specified node in a circular doubly linked list.  <a href="dlist_8h.html#a0d504f97bec128e16205f0fa63bce82f">More...</a><br /></td></tr>
<tr class="separator:a0d504f97bec128e16205f0fa63bce82f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a103da03cca6343606bc32a3c6a8fec9c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dlist_8h.html#a103da03cca6343606bc32a3c6a8fec9c">dlist_insert_before</a>(dlist,  existing_node,  node_to_insert)</td></tr>
<tr class="memdesc:a103da03cca6343606bc32a3c6a8fec9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element before a specified node in a circular doubly linked list.  <a href="dlist_8h.html#a103da03cca6343606bc32a3c6a8fec9c">More...</a><br /></td></tr>
<tr class="separator:a103da03cca6343606bc32a3c6a8fec9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a0a945596fd137b14273b421383b45734"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structdlist__node__t.html">dlist_node_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dlist_8h.html#a0a945596fd137b14273b421383b45734">dlist_node_t</a></td></tr>
<tr class="memdesc:a0a945596fd137b14273b421383b45734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for the structure representing a node in a circular doubly linked list.  <a href="dlist_8h.html#a0a945596fd137b14273b421383b45734">More...</a><br /></td></tr>
<tr class="separator:a0a945596fd137b14273b421383b45734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95cb0e87f5c2fc68cda38f6b98c77b7"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structdlist__node__t.html">dlist_node_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dlist_8h.html#af95cb0e87f5c2fc68cda38f6b98c77b7">dlist_t</a></td></tr>
<tr class="memdesc:af95cb0e87f5c2fc68cda38f6b98c77b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for the circular doubly linked list.  <a href="dlist_8h.html#af95cb0e87f5c2fc68cda38f6b98c77b7">More...</a><br /></td></tr>
<tr class="separator:af95cb0e87f5c2fc68cda38f6b98c77b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a643bd1eb05da6561fcf98ea81bf160c6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dlist_8h.html#a643bd1eb05da6561fcf98ea81bf160c6">dlist_size</a> (<a class="el" href="dlist_8h.html#af95cb0e87f5c2fc68cda38f6b98c77b7">dlist_t</a> *dlist)</td></tr>
<tr class="memdesc:a643bd1eb05da6561fcf98ea81bf160c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of nodes in a circular doubly linked list.  <a href="dlist_8h.html#a643bd1eb05da6561fcf98ea81bf160c6">More...</a><br /></td></tr>
<tr class="separator:a643bd1eb05da6561fcf98ea81bf160c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba7d109449bb740a61d7e8558b1c9321"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdlist__node__t.html">dlist_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dlist_8h.html#aba7d109449bb740a61d7e8558b1c9321">dlist_find</a> (<a class="el" href="dlist_8h.html#af95cb0e87f5c2fc68cda38f6b98c77b7">dlist_t</a> *dlist, void *node)</td></tr>
<tr class="memdesc:aba7d109449bb740a61d7e8558b1c9321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a node is in the circular doubly linked list.  <a href="dlist_8h.html#aba7d109449bb740a61d7e8558b1c9321">More...</a><br /></td></tr>
<tr class="separator:aba7d109449bb740a61d7e8558b1c9321"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Circular doubly linked list. </p>
<dl class="section copyright"><dt>Copyright</dt><dd></dd></dl>
<p><a href="https://opensource.org/license/mit/">https://opensource.org/license/mit/</a></p>
<p>Copyright 2013-2023 Marco Bacchi <a href="#" onclick="location.href='mai'+'lto:'+'mar'+'co'+'@ba'+'cc'+'hi.'+'at'; return false;">marco<span style="display: none;">.nosp@m.</span>@bac<span style="display: none;">.nosp@m.</span>chi.a<span style="display: none;">.nosp@m.</span>t</a></p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>
<dl class="section author"><dt>Authors</dt><dd><a href="#" onclick="location.href='mai'+'lto:'+'mar'+'co'+'@ba'+'cc'+'hi.'+'at'; return false;">marco<span style="display: none;">.nosp@m.</span>@bac<span style="display: none;">.nosp@m.</span>chi.a<span style="display: none;">.nosp@m.</span>t</a></dd></dl>
<p>In computer science, a linked list is a linear collection of data elements, whose order is not given by their physical placement in memory. Instead, each element points to the next. It is a data structure consisting of a collection of nodes which together represent a sequence. In its most basic form, each node contains: data, and a reference (in other words, a link) to the next node in the sequence. This structure allows for efficient insertion or removal of elements from any position in the sequence during iteration. [<a href="https://en.wikipedia.org/wiki/Linked_list">https://en.wikipedia.org/wiki/Linked_list</a>]</p>
<p>In a 'doubly linked list', each node contains, besides the next-node link, a second link field pointing to the 'previous' node in the sequence. The two links may be called 'forward('s') and 'backwards', or 'next' and 'prev'('previous'). [<a href="https://en.wikipedia.org/wiki/Linked_list#Doubly_linked_list">https://en.wikipedia.org/wiki/Linked_list#Doubly_linked_list</a>]</p>
<p>In the last node of a list, the link field often contains a null reference, a special value is used to indicate the lack of further nodes. A less common convention is to make it point to the first node of the list; in that case, the list is said to be 'circular' or 'circularly linked'; otherwise, it is said to be 'open' or 'linear'. It is a list where the last pointer points to the first node. [<a href="https://en.wikipedia.org/wiki/Linked_list#Circular_linked_list">https://en.wikipedia.org/wiki/Linked_list#Circular_linked_list</a>]</p>
<dl class="section copyright"><dt>Copyright</dt><dd></dd></dl>
<p><a href="https://opensource.org/license/mit/">https://opensource.org/license/mit/</a></p>
<p>Copyright 2013-2023 Marco Bacchi <a href="#" onclick="location.href='mai'+'lto:'+'mar'+'co'+'@ba'+'cc'+'hi.'+'at'; return false;">marco<span style="display: none;">.nosp@m.</span>@bac<span style="display: none;">.nosp@m.</span>chi.a<span style="display: none;">.nosp@m.</span>t</a></p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright 2013-2023 Marco Bacchi <a href="#" onclick="location.href='mai'+'lto:'+'mar'+'co'+'@ba'+'cc'+'hi.'+'at'; return false;">marco<span style="display: none;">.nosp@m.</span>@bac<span style="display: none;">.nosp@m.</span>chi.a<span style="display: none;">.nosp@m.</span>t</a> </dd></dl>
<dl class="section user"><dt>License:</dt><dd>This file is released under the MIT License.<br  />
 <a href="https://opensource.org/licenses/MIT">https://opensource.org/licenses/MIT</a></dd></dl>
<p>In computer science, a linked list is a linear collection of data elements, whose order is not given by their physical placement in memory. Instead, each element points to the next. It is a data structure consisting of a collection of nodes which together represent a sequence. In its most basic form, each node contains: data, and a reference (in other words, a link) to the next node in the sequence. This structure allows for efficient insertion or removal of elements from any position in the sequence during iteration. [<a href="https://en.wikipedia.org/wiki/Linked_list">https://en.wikipedia.org/wiki/Linked_list</a>]</p>
<p>In a 'doubly linked list', each node contains, besides the next-node link, a second link field pointing to the 'previous' node in the sequence. The two links may be called 'forward('s') and 'backwards', or 'next' and 'prev'('previous'). [<a href="https://en.wikipedia.org/wiki/Linked_list#Doubly_linked_list">https://en.wikipedia.org/wiki/Linked_list#Doubly_linked_list</a>]</p>
<p>In the last node of a list, the link field often contains a null reference, a special value is used to indicate the lack of further nodes. A less common convention is to make it point to the first node of the list; in that case, the list is said to be 'circular' or 'circularly linked'; otherwise, it is said to be 'open' or 'linear'. It is a list where the last pointer points to the first node. [<a href="https://en.wikipedia.org/wiki/Linked_list#Circular_linked_list">https://en.wikipedia.org/wiki/Linked_list#Circular_linked_list</a>]</p>
<p>Comparison Singly Linked List vs. Doubly Linked List:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Singly Linked List   </th><th class="markdownTableHeadNone">Doubly Linked List    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Linked lists are not stored in contiguous location.   </td><td class="markdownTableBodyNone">Linked lists are not stored in contiguous location.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Dynamic in size.   </td><td class="markdownTableBodyNone">Dynamic in size.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Memory is allocated at run time (not necessarily true).   </td><td class="markdownTableBodyNone">Memory is allocated at run time (not necessarily true).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Uses less memory than a doubly linked list.   </td><td class="markdownTableBodyNone">Uses more memory as it also stores the address of the previous node.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Element accessing requires the traversal of whole linked list.   </td><td class="markdownTableBodyNone">Element accessing requires the traversal of whole linked list.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Insertion and deletion operation is slower.   </td><td class="markdownTableBodyNone">Insertion and deletion operation is faster.   </td></tr>
</table>
<p>This file was redocumented in doxygen style format by using ChatGPT 4. <br  />
 Input : existing doxygen documentation and source for each documentation entity <br  />
 Request : Extend doxygen documentation part <br  />
 Output : New doxygen documentation <br  />
</p>

<p class="definition">Definition in file <a class="el" href="dlist_8h_source.html">dlist.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ad1d2033bf85a976df0264660e75897f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d2033bf85a976df0264660e75897f4">&#9670;&nbsp;</a></span>dlist_back</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define dlist_back</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dlist</td><td>)</td>
          <td>&#160;&#160;&#160;(<a class="el" href="dlist_8h.html#a79b530d7d8bc62657ffb605744bbc497">dlist_prev</a>(dlist,dlist))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the last node in a circular doubly linked list. </p>
<p>This macro provides an iterator to the last node in a circular doubly linked list. It uses the <code>dlist_prev</code> macro to find the node that precedes the list node itself (<code>dlist</code>). In a circular doubly linked list, the 'prev' pointer of the list node points to the last element, making this an efficient method to access the last node.</p>
<p>This is particularly useful for operations that require access to the end of the list, such as appending elements or performing operations in reverse order. It is important to note that if the list is empty, the macro will return the list node itself, which should not be treated as a valid data-containing node.</p>
<p>Usage: </p><div class="fragment"><div class="line"><a class="code" href="structdlist__node__t.html">dlist_t</a> mylist;</div>
<div class="line"><a class="code" href="dlist_8h.html#a91b88be10a7e1ecc7763abae712aa7fc">dlist_init</a>(&amp;mylist);</div>
<div class="line"><span class="comment">// Add elements to the list</span></div>
<div class="line"><a class="code" href="structdlist__node__t.html">dlist_node_t</a> *last_node = <a class="code" href="dlist_8h.html#ad1d2033bf85a976df0264660e75897f4">dlist_back</a>(&amp;mylist);</div>
<div class="line"><span class="keywordflow">if</span> (last_node != &amp;mylist) {</div>
<div class="line">    <span class="comment">// The list is not empty, process the last node</span></div>
<div class="line">}</div>
<div class="ttc" id="adlist_8h_html_a91b88be10a7e1ecc7763abae712aa7fc"><div class="ttname"><a href="dlist_8h.html#a91b88be10a7e1ecc7763abae712aa7fc">dlist_init</a></div><div class="ttdeci">#define dlist_init(dlist)</div><div class="ttdoc">Initializes a circular doubly linked list.</div><div class="ttdef"><b>Definition:</b> <a href="dlist_8h_source.html#l00187">dlist.h:187</a></div></div>
<div class="ttc" id="adlist_8h_html_ad1d2033bf85a976df0264660e75897f4"><div class="ttname"><a href="dlist_8h.html#ad1d2033bf85a976df0264660e75897f4">dlist_back</a></div><div class="ttdeci">#define dlist_back(dlist)</div><div class="ttdoc">Returns the last node in a circular doubly linked list.</div><div class="ttdef"><b>Definition:</b> <a href="dlist_8h_source.html#l00308">dlist.h:308</a></div></div>
<div class="ttc" id="astructdlist__node__t_html"><div class="ttname"><a href="structdlist__node__t.html">dlist_node_t</a></div><div class="ttdoc">Structure representing a node in a circular doubly linked list.</div><div class="ttdef"><b>Definition:</b> <a href="dlist_8h_source.html#l00669">dlist.h:669</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dlist</td><td>A pointer to the circular doubly linked list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the last node in the list, or the list node itself if the list is empty. </dd></dl>

<p class="definition">Definition at line <a class="el" href="dlist_8h_source.html#l00308">308</a> of file <a class="el" href="dlist_8h_source.html">dlist.h</a>.</p>

</div>
</div>
<a id="aa4882a8fe635c6d04587830d7816473e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4882a8fe635c6d04587830d7816473e">&#9670;&nbsp;</a></span>dlist_begin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define dlist_begin</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dlist</td><td>)</td>
          <td>&#160;&#160;&#160;((dlist)-&gt;next)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning of the list. </p>
<p>This macro provides an iterator pointing to the first element in a circular doubly linked list. It returns the node immediately following the list node, which is considered the first element of the list. If the list is empty, this iterator will point back to the list node itself.</p>
<p>It is important to note that if the list is empty, the returned iterator should not be dereferenced, as it would point to the list node instead of a valid data node. Users should check whether the list is empty (e.g., using <code>dlist_empty</code>) before dereferencing the iterator.</p>
<p>Usage: </p><div class="fragment"><div class="line"><a class="code" href="structdlist__node__t.html">dlist_t</a> mylist;</div>
<div class="line"><a class="code" href="dlist_8h.html#a91b88be10a7e1ecc7763abae712aa7fc">dlist_init</a>(&amp;mylist);</div>
<div class="line"><span class="comment">// Add elements to the list</span></div>
<div class="line"><a class="code" href="structdlist__node__t.html">dlist_node_t</a> *begin = <a class="code" href="dlist_8h.html#aa4882a8fe635c6d04587830d7816473e">dlist_begin</a>(&amp;mylist);</div>
<div class="line"><span class="keywordflow">if</span> (begin != &amp;mylist) {</div>
<div class="line">    <span class="comment">// The list is not empty, process the first element</span></div>
<div class="line">}</div>
<div class="ttc" id="adlist_8h_html_aa4882a8fe635c6d04587830d7816473e"><div class="ttname"><a href="dlist_8h.html#aa4882a8fe635c6d04587830d7816473e">dlist_begin</a></div><div class="ttdeci">#define dlist_begin(dlist)</div><div class="ttdoc">Returns an iterator to the beginning of the list.</div><div class="ttdef"><b>Definition:</b> <a href="dlist_8h_source.html#l00219">dlist.h:219</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dlist</td><td>A pointer to the circular doubly linked list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator (pointer) to the first node in the list, or to the list node itself if the list is empty. </dd></dl>

<p class="definition">Definition at line <a class="el" href="dlist_8h_source.html#l00219">219</a> of file <a class="el" href="dlist_8h_source.html">dlist.h</a>.</p>

</div>
</div>
<a id="a32d6434a21efbaa32af5c6ea7778fbca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32d6434a21efbaa32af5c6ea7778fbca">&#9670;&nbsp;</a></span>dlist_empty</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define dlist_empty</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dlist</td><td>)</td>
          <td>&#160;&#160;&#160;((dlist)-&gt;next==(dlist))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether a circular doubly linked list is empty. </p>
<p>This macro checks if a circular doubly linked list is empty by comparing the 'next' pointer of the list node (<code>dlist</code>) to the address of the list node itself. In an empty circular doubly linked list, the 'next' and 'prev' pointers of the list node point to the list node itself. If the 'next' pointer points to the list node, the list is empty. Otherwise, it contains at least one element.</p>
<p>This is a quick and efficient way to determine if the list has any elements without traversing the entire list. It is particularly useful for checking list state before performing operations that require the list to have elements.</p>
<p>Usage: </p><div class="fragment"><div class="line"><a class="code" href="structdlist__node__t.html">dlist_t</a> mylist;</div>
<div class="line"><a class="code" href="dlist_8h.html#a91b88be10a7e1ecc7763abae712aa7fc">dlist_init</a>(&amp;mylist);</div>
<div class="line"><span class="comment">// Operations that may modify the list</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="dlist_8h.html#a32d6434a21efbaa32af5c6ea7778fbca">dlist_empty</a>(&amp;mylist)) {</div>
<div class="line">    <span class="comment">// The list is empty, handle accordingly</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// The list is not empty, proceed with further operations</span></div>
<div class="line">}</div>
<div class="ttc" id="adlist_8h_html_a32d6434a21efbaa32af5c6ea7778fbca"><div class="ttname"><a href="dlist_8h.html#a32d6434a21efbaa32af5c6ea7778fbca">dlist_empty</a></div><div class="ttdeci">#define dlist_empty(dlist)</div><div class="ttdoc">Tests whether a circular doubly linked list is empty.</div><div class="ttdef"><b>Definition:</b> <a href="dlist_8h_source.html#l00372">dlist.h:372</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dlist</td><td>A pointer to the circular doubly linked list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An integer: 0 if the list is not empty, or 1 if it is empty. </dd></dl>

<p class="definition">Definition at line <a class="el" href="dlist_8h_source.html#l00372">372</a> of file <a class="el" href="dlist_8h_source.html">dlist.h</a>.</p>

</div>
</div>
<a id="a6d3fcaf247e1020ca87d6cb65757a935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d3fcaf247e1020ca87d6cb65757a935">&#9670;&nbsp;</a></span>dlist_end</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define dlist_end</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dlist</td><td>)</td>
          <td>&#160;&#160;&#160;(dlist)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the past-the-end element in a circular doubly linked list. </p>
<p>This macro provides an iterator referring to the past-the-end element in a circular doubly linked list. The past-the-end element is a theoretical element that follows the last element in the list. It is not a valid element and thus shall not be dereferenced. This iterator is commonly used in combination with <code>dlist_begin</code> to specify a range that includes all the elements in the container.</p>
<p>In a circular doubly linked list, the successor of the last element is the list node itself, signifying the end of the list. Therefore, this macro returns the list node to represent the past-the-end element. It is particularly useful for loop conditions and iterator comparisons where a sentinel value is needed to represent the end of the list.</p>
<p>Usage: </p><div class="fragment"><div class="line"><a class="code" href="structdlist__node__t.html">dlist_t</a> mylist;</div>
<div class="line"><a class="code" href="dlist_8h.html#a91b88be10a7e1ecc7763abae712aa7fc">dlist_init</a>(&amp;mylist);</div>
<div class="line"><span class="comment">// Add elements to the list</span></div>
<div class="line"><span class="keywordflow">for</span> (<a class="code" href="structdlist__node__t.html">dlist_node_t</a> *it = <a class="code" href="dlist_8h.html#aa4882a8fe635c6d04587830d7816473e">dlist_begin</a>(&amp;mylist); it != <a class="code" href="dlist_8h.html#a6d3fcaf247e1020ca87d6cb65757a935">dlist_end</a>(&amp;mylist); it = <a class="code" href="dlist_8h.html#a5d22ada75e1ef9d60ebe8d580f5ea05b">dlist_next</a>(&amp;mylist, it)) {</div>
<div class="line">    <span class="comment">// Process each element</span></div>
<div class="line">}</div>
<div class="ttc" id="adlist_8h_html_a5d22ada75e1ef9d60ebe8d580f5ea05b"><div class="ttname"><a href="dlist_8h.html#a5d22ada75e1ef9d60ebe8d580f5ea05b">dlist_next</a></div><div class="ttdeci">#define dlist_next(dlist, existing_node)</div><div class="ttdoc">Retrieves the next node in a circular doubly linked list.</div><div class="ttdef"><b>Definition:</b> <a href="dlist_8h_source.html#l00134">dlist.h:134</a></div></div>
<div class="ttc" id="adlist_8h_html_a6d3fcaf247e1020ca87d6cb65757a935"><div class="ttname"><a href="dlist_8h.html#a6d3fcaf247e1020ca87d6cb65757a935">dlist_end</a></div><div class="ttdeci">#define dlist_end(dlist)</div><div class="ttdoc">Returns an iterator to the past-the-end element in a circular doubly linked list.</div><div class="ttdef"><b>Definition:</b> <a href="dlist_8h_source.html#l00278">dlist.h:278</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dlist</td><td>A pointer to the circular doubly linked list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator referring to the past-the-end element, which is the list node itself. </dd></dl>

<p class="definition">Definition at line <a class="el" href="dlist_8h_source.html#l00278">278</a> of file <a class="el" href="dlist_8h_source.html">dlist.h</a>.</p>

</div>
</div>
<a id="afafccb52bd9b1129aa39c59f6f3fbcd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afafccb52bd9b1129aa39c59f6f3fbcd3">&#9670;&nbsp;</a></span>dlist_erase</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define dlist_erase</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dlist, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">existing_node&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">do</span>{ \</div>
<div class="line">        ((<a class="code" href="structdlist__node__t.html">dlist_node_t</a>*)existing_node)-&gt;prev-&gt;next = ((<a class="code" href="structdlist__node__t.html">dlist_node_t</a>*)existing_node)-&gt;next; \</div>
<div class="line">        ((<a class="code" href="structdlist__node__t.html">dlist_node_t</a>*)existing_node)-&gt;next-&gt;prev = ((<a class="code" href="structdlist__node__t.html">dlist_node_t</a>*)existing_node)-&gt;prev; \</div>
<div class="line">    } <span class="keywordflow">while</span>(0)</div>
</div><!-- fragment -->
<p>Removes a specific node from a circular doubly linked list. </p>
<p>This macro removes a specific node (<code>existing_node</code>) from the circular doubly linked list. It achieves this by adjusting the 'next' pointer of the node's predecessor and the 'prev' pointer of the node's successor to bypass <code>existing_node</code>, effectively removing it from the list.</p>
<p>This operation is efficient as it directly manipulates the pointers of the neighboring nodes, and does not require traversing the list. It is crucial to ensure that <code>existing_node</code> is indeed a member of the list; removing a node that is not part of the list will result in undefined behavior.</p>
<p>Users should also handle memory management for the removed node if it was dynamically allocated. This macro only removes the node from the list structure; it does not free the memory associated with the node.</p>
<p>Usage: </p><div class="fragment"><div class="line"><a class="code" href="structdlist__node__t.html">dlist_t</a> mylist;</div>
<div class="line"><a class="code" href="dlist_8h.html#a91b88be10a7e1ecc7763abae712aa7fc">dlist_init</a>(&amp;mylist);</div>
<div class="line"><span class="comment">// Add elements to the list</span></div>
<div class="line"><a class="code" href="structdlist__node__t.html">dlist_node_t</a> *node_to_remove = find_node(mylist, some_criteria); <span class="comment">// Assume find_node returns a valid node</span></div>
<div class="line"><span class="keywordflow">if</span> (node_to_remove) {</div>
<div class="line">    <a class="code" href="dlist_8h.html#afafccb52bd9b1129aa39c59f6f3fbcd3">dlist_erase</a>(&amp;mylist, node_to_remove);</div>
<div class="line">    <span class="comment">// Now &#39;node_to_remove&#39; is removed from &#39;mylist&#39;</span></div>
<div class="line">    <span class="comment">// Free node_to_remove if necessary</span></div>
<div class="line">}</div>
<div class="ttc" id="adlist_8h_html_afafccb52bd9b1129aa39c59f6f3fbcd3"><div class="ttname"><a href="dlist_8h.html#afafccb52bd9b1129aa39c59f6f3fbcd3">dlist_erase</a></div><div class="ttdeci">#define dlist_erase(dlist, existing_node)</div><div class="ttdoc">Removes a specific node from a circular doubly linked list.</div><div class="ttdef"><b>Definition:</b> <a href="dlist_8h_source.html#l00560">dlist.h:560</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dlist</td><td>A pointer to the circular doubly linked list. </td></tr>
    <tr><td class="paramname">existing_node</td><td>A pointer to the node to be removed from the list. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="dlist_8h_source.html#l00560">560</a> of file <a class="el" href="dlist_8h_source.html">dlist.h</a>.</p>

</div>
</div>
<a id="a6f810c5c180e951efd3e89eca994dfb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f810c5c180e951efd3e89eca994dfb5">&#9670;&nbsp;</a></span>dlist_foreach</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define dlist_foreach</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dlist, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iterator&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    for(iterator = (void*)<a class="el" href="dlist_8h.html#aa4882a8fe635c6d04587830d7816473e">dlist_begin</a>(dlist); ((<a class="el" href="structdlist__node__t.html">dlist_node_t</a>*)iterator) != <a class="el" href="dlist_8h.html#a6d3fcaf247e1020ca87d6cb65757a935">dlist_end</a>(dlist); iterator=(void*)<a class="el" href="dlist_8h.html#a5d22ada75e1ef9d60ebe8d580f5ea05b">dlist_next</a>(dlist,iterator))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterates through all elements in a circular doubly linked list. </p>
<p>This macro sets up a loop that iterates from the first to the last element in a circular doubly linked list. It initializes the iterator to the first element in the list using <code>dlist_begin</code>, and then continues to iterate over each element until it reaches the end of the list, indicated by <code>dlist_end</code>. This macro is useful for performing operations on each element in the list, such as searching, modifying, or printing values.</p>
<p>The macro uses a for loop to traverse the list, making it easy to apply a block of code to each element. It is important to ensure that the list is properly initialized before using this macro to avoid undefined behavior.</p>
<p>Usage: </p><div class="fragment"><div class="line"><a class="code" href="structdlist__node__t.html">dlist_t</a> mylist;</div>
<div class="line"><a class="code" href="dlist_8h.html#a91b88be10a7e1ecc7763abae712aa7fc">dlist_init</a>(&amp;mylist);</div>
<div class="line"><span class="comment">// Add elements to the list</span></div>
<div class="line"><a class="code" href="structdlist__node__t.html">dlist_node_t</a> *iterator;</div>
<div class="line"><a class="code" href="dlist_8h.html#a6f810c5c180e951efd3e89eca994dfb5">dlist_foreach</a>(&amp;mylist, iterator) {</div>
<div class="line">    <span class="comment">// Process each element pointed to by iterator</span></div>
<div class="line">}</div>
<div class="ttc" id="adlist_8h_html_a6f810c5c180e951efd3e89eca994dfb5"><div class="ttname"><a href="dlist_8h.html#a6f810c5c180e951efd3e89eca994dfb5">dlist_foreach</a></div><div class="ttdeci">#define dlist_foreach(dlist, iterator)</div><div class="ttdoc">Iterates through all elements in a circular doubly linked list.</div><div class="ttdef"><b>Definition:</b> <a href="dlist_8h_source.html#l00339">dlist.h:339</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dlist</td><td>A pointer to the circular doubly linked list to be iterated over. </td></tr>
    <tr><td class="paramname">iterator</td><td>A pointer that will be used as an iterator over the list. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="dlist_8h_source.html#l00339">339</a> of file <a class="el" href="dlist_8h_source.html">dlist.h</a>.</p>

</div>
</div>
<a id="a6f6a586785093d37647d26709d9d90c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f6a586785093d37647d26709d9d90c8">&#9670;&nbsp;</a></span>dlist_front</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define dlist_front</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dlist</td><td>)</td>
          <td>&#160;&#160;&#160;(<a class="el" href="dlist_8h.html#aa4882a8fe635c6d04587830d7816473e">dlist_begin</a>(dlist))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the first element in a circular doubly linked list. </p>
<p>This macro provides access to the first data-containing node in a circular doubly linked list. It utilizes the <code>dlist_begin</code> macro to obtain an iterator pointing to the first element. If the list is empty, it returns an iterator pointing to the list node itself, which should not be dereferenced.</p>
<p>The <code>dlist_front</code> macro is useful for accessing the first element of the list in a direct and concise way. However, users should verify that the list is not empty before attempting to use the returned iterator to access list data.</p>
<p>Usage: </p><div class="fragment"><div class="line"><a class="code" href="structdlist__node__t.html">dlist_t</a> mylist;</div>
<div class="line"><a class="code" href="dlist_8h.html#a91b88be10a7e1ecc7763abae712aa7fc">dlist_init</a>(&amp;mylist);</div>
<div class="line"><span class="comment">// Add elements to the list</span></div>
<div class="line"><a class="code" href="structdlist__node__t.html">dlist_node_t</a> *front = <a class="code" href="dlist_8h.html#a6f6a586785093d37647d26709d9d90c8">dlist_front</a>(&amp;mylist);</div>
<div class="line"><span class="keywordflow">if</span> (front != &amp;mylist) {</div>
<div class="line">    <span class="comment">// The list is not empty, access the data of the first element</span></div>
<div class="line">}</div>
<div class="ttc" id="adlist_8h_html_a6f6a586785093d37647d26709d9d90c8"><div class="ttname"><a href="dlist_8h.html#a6f6a586785093d37647d26709d9d90c8">dlist_front</a></div><div class="ttdeci">#define dlist_front(dlist)</div><div class="ttdoc">Retrieves the first element in a circular doubly linked list.</div><div class="ttdef"><b>Definition:</b> <a href="dlist_8h_source.html#l00248">dlist.h:248</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dlist</td><td>A pointer to the circular doubly linked list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator (pointer) to the first element in the list, or to the list node itself if the list is empty. </dd></dl>

<p class="definition">Definition at line <a class="el" href="dlist_8h_source.html#l00248">248</a> of file <a class="el" href="dlist_8h_source.html">dlist.h</a>.</p>

</div>
</div>
<a id="a91b88be10a7e1ecc7763abae712aa7fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91b88be10a7e1ecc7763abae712aa7fc">&#9670;&nbsp;</a></span>dlist_init</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define dlist_init</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dlist</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">do</span>{ \</div>
<div class="line">        (dlist)-&gt;next = (dlist); \</div>
<div class="line">        (dlist)-&gt;prev = (dlist); \</div>
<div class="line">    }<span class="keywordflow">while</span>(0)</div>
</div><!-- fragment -->
<p>Initializes a circular doubly linked list. </p>
<p>This macro is used to initialize a circular doubly linked list, setting it up as an empty list. In an empty list, both the 'next' and 'prev' pointers of the list node point to the list node itself, creating a circular structure. Initializing the list in this way is crucial, as it ensures that the list is in a known state, preventing undefined behavior when performing other operations on the list.</p>
<p>Proper initialization of the list is essential before using any other list functions or function-like macros, as they rely on the list being correctly initialized to a circular structure.</p>
<p>Usage: </p><div class="fragment"><div class="line"><a class="code" href="structdlist__node__t.html">dlist_t</a> mylist;</div>
<div class="line"><a class="code" href="dlist_8h.html#a91b88be10a7e1ecc7763abae712aa7fc">dlist_init</a>(&amp;mylist);</div>
<div class="line"><span class="comment">// Now &#39;mylist&#39; is initialized and ready for operations</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dlist</td><td>A pointer to the circular doubly linked list to be initialized. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="dlist_8h_source.html#l00187">187</a> of file <a class="el" href="dlist_8h_source.html">dlist.h</a>.</p>

</div>
</div>
<a id="a0d504f97bec128e16205f0fa63bce82f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d504f97bec128e16205f0fa63bce82f">&#9670;&nbsp;</a></span>dlist_insert_after</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define dlist_insert_after</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dlist, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">existing_node, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node_to_insert&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">do</span>{ \</div>
<div class="line">        ((<a class="code" href="structdlist__node__t.html">dlist_node_t</a>*)node_to_insert)-&gt;next = ((<a class="code" href="structdlist__node__t.html">dlist_node_t</a>*)existing_node)-&gt;next; \</div>
<div class="line">        ((<a class="code" href="structdlist__node__t.html">dlist_node_t</a>*)node_to_insert)-&gt;prev = existing_node; \</div>
<div class="line">        ((<a class="code" href="structdlist__node__t.html">dlist_node_t</a>*)existing_node)-&gt;next-&gt;prev = node_to_insert; \</div>
<div class="line">        ((<a class="code" href="structdlist__node__t.html">dlist_node_t</a>*)existing_node)-&gt;next = node_to_insert; \</div>
<div class="line">    } <span class="keywordflow">while</span>(0)</div>
</div><!-- fragment -->
<p>Inserts an element after a specified node in a circular doubly linked list. </p>
<p>This macro inserts a new node (<code>node_to_insert</code>) into the circular doubly linked list immediately after a specified node (<code>existing_node</code>). The insertion is achieved by adjusting the 'next' and 'prev' pointers of <code>node_to_insert</code>, as well as the 'next' pointer of <code>existing_node</code> and the 'prev' pointer of the original successor of <code>existing_node</code>.</p>
<p>This operation allows for efficient insertion in the list without needing to traverse it. It is crucial that both <code>existing_node</code> and <code>node_to_insert</code> are valid pointers to nodes properly allocated. The macro assumes that <code>existing_node</code> is a part of the list and <code>node_to_insert</code> is not yet in the list. Improper usage may lead to undefined behavior.</p>
<p>Users should ensure that <code>node_to_insert</code> is correctly initialized before using this macro, as it only handles the linking of the node into the list structure.</p>
<p>Usage: </p><div class="fragment"><div class="line"><a class="code" href="structdlist__node__t.html">dlist_t</a> mylist;</div>
<div class="line"><a class="code" href="dlist_8h.html#a91b88be10a7e1ecc7763abae712aa7fc">dlist_init</a>(&amp;mylist);</div>
<div class="line"><a class="code" href="structdlist__node__t.html">dlist_node_t</a> *existing_node = find_node(mylist, some_criteria); <span class="comment">// Assume find_node returns a valid node</span></div>
<div class="line"><a class="code" href="structdlist__node__t.html">dlist_node_t</a> *new_node = create_node(data); <span class="comment">// Assume create_node allocates and initializes a new node</span></div>
<div class="line"><a class="code" href="dlist_8h.html#a0d504f97bec128e16205f0fa63bce82f">dlist_insert_after</a>(&amp;mylist, existing_node, new_node);</div>
<div class="line"><span class="comment">// Now &#39;new_node&#39; is inserted after &#39;existing_node&#39; in &#39;mylist&#39;</span></div>
<div class="ttc" id="adlist_8h_html_a0d504f97bec128e16205f0fa63bce82f"><div class="ttname"><a href="dlist_8h.html#a0d504f97bec128e16205f0fa63bce82f">dlist_insert_after</a></div><div class="ttdeci">#define dlist_insert_after(dlist, existing_node, node_to_insert)</div><div class="ttdoc">Inserts an element after a specified node in a circular doubly linked list.</div><div class="ttdef"><b>Definition:</b> <a href="dlist_8h_source.html#l00600">dlist.h:600</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dlist</td><td>A pointer to the circular doubly linked list. </td></tr>
    <tr><td class="paramname">existing_node</td><td>A pointer to the node in the list after which the new node will be inserted. </td></tr>
    <tr><td class="paramname">node_to_insert</td><td>A pointer to the new node to be inserted into the list. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="dlist_8h_source.html#l00600">600</a> of file <a class="el" href="dlist_8h_source.html">dlist.h</a>.</p>

</div>
</div>
<a id="a103da03cca6343606bc32a3c6a8fec9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a103da03cca6343606bc32a3c6a8fec9c">&#9670;&nbsp;</a></span>dlist_insert_before</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define dlist_insert_before</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dlist, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">existing_node, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node_to_insert&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">do</span>{ \</div>
<div class="line">        ((<a class="code" href="structdlist__node__t.html">dlist_node_t</a>*)node_to_insert)-&gt;next = existing_node; \</div>
<div class="line">        ((<a class="code" href="structdlist__node__t.html">dlist_node_t</a>*)node_to_insert)-&gt;prev = ((<a class="code" href="structdlist__node__t.html">dlist_node_t</a>*)existing_node)-&gt;prev; \</div>
<div class="line">        ((<a class="code" href="structdlist__node__t.html">dlist_node_t</a>*)existing_node)-&gt;prev-&gt;next = node_to_insert; \</div>
<div class="line">        ((<a class="code" href="structdlist__node__t.html">dlist_node_t</a>*)existing_node)-&gt;prev = node_to_insert; \</div>
<div class="line">    } <span class="keywordflow">while</span>(0)</div>
</div><!-- fragment -->
<p>Inserts an element before a specified node in a circular doubly linked list. </p>
<p>This macro inserts a new node (<code>node_to_insert</code>) into the circular doubly linked list immediately before a specified node (<code>existing_node</code>). The insertion is achieved by adjusting the 'next' and 'prev' pointers of <code>node_to_insert</code>, as well as the 'prev' pointer of <code>existing_node</code> and the 'next' pointer of the original predecessor of <code>existing_node</code>.</p>
<p>This operation allows for efficient insertion in the list without needing to traverse it. It is crucial that both <code>existing_node</code> and <code>node_to_insert</code> are valid pointers to nodes properly allocated. The macro assumes that <code>existing_node</code> is a part of the list and <code>node_to_insert</code> is not yet in the list. Improper usage may lead to undefined behavior.</p>
<p>Users should ensure that <code>node_to_insert</code> is correctly initialized before using this macro, as it only handles the linking of the node into the list structure.</p>
<p>Usage: </p><div class="fragment"><div class="line"><a class="code" href="structdlist__node__t.html">dlist_t</a> mylist;</div>
<div class="line"><a class="code" href="dlist_8h.html#a91b88be10a7e1ecc7763abae712aa7fc">dlist_init</a>(&amp;mylist);</div>
<div class="line"><a class="code" href="structdlist__node__t.html">dlist_node_t</a> *existing_node = find_node(mylist, some_criteria); <span class="comment">// Assume find_node returns a valid node</span></div>
<div class="line"><a class="code" href="structdlist__node__t.html">dlist_node_t</a> *new_node = create_node(data); <span class="comment">// Assume create_node allocates and initializes a new node</span></div>
<div class="line"><a class="code" href="dlist_8h.html#a103da03cca6343606bc32a3c6a8fec9c">dlist_insert_before</a>(&amp;mylist, existing_node, new_node);</div>
<div class="line"><span class="comment">// Now &#39;new_node&#39; is inserted before &#39;existing_node&#39; in &#39;mylist&#39;</span></div>
<div class="ttc" id="adlist_8h_html_a103da03cca6343606bc32a3c6a8fec9c"><div class="ttname"><a href="dlist_8h.html#a103da03cca6343606bc32a3c6a8fec9c">dlist_insert_before</a></div><div class="ttdeci">#define dlist_insert_before(dlist, existing_node, node_to_insert)</div><div class="ttdoc">Inserts an element before a specified node in a circular doubly linked list.</div><div class="ttdef"><b>Definition:</b> <a href="dlist_8h_source.html#l00641">dlist.h:641</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dlist</td><td>A pointer to the circular doubly linked list. </td></tr>
    <tr><td class="paramname">existing_node</td><td>A pointer to the node in the list before which the new node will be inserted. </td></tr>
    <tr><td class="paramname">node_to_insert</td><td>A pointer to the new node to be inserted into the list. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="dlist_8h_source.html#l00641">641</a> of file <a class="el" href="dlist_8h_source.html">dlist.h</a>.</p>

</div>
</div>
<a id="a5d22ada75e1ef9d60ebe8d580f5ea05b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d22ada75e1ef9d60ebe8d580f5ea05b">&#9670;&nbsp;</a></span>dlist_next</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define dlist_next</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dlist, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">existing_node&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    (((<a class="el" href="structdlist__node__t.html">dlist_node_t</a>*)(existing_node))-&gt;next)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the next node in a circular doubly linked list. </p>
<p>This macro provides an efficient way to access the successor of a given node (<code>existing_node</code>) in a circular doubly linked list. It returns the node that immediately follows the specified node in the list. This is particularly useful for iterating over a circular doubly linked list, where each node is connected to both its predecessor and successor.</p>
<p>The macro assumes that <code>existing_node</code> is not NULL and is a valid member of the list. If <code>existing_node</code> is the last node in the list, <code>dlist_next</code> returns the list node itself, as the next node in the circular structure.</p>
<p>Usage: </p><div class="fragment"><div class="line"><a class="code" href="structdlist__node__t.html">dlist_node_t</a> *current = get_some_node(dlist);</div>
<div class="line"><a class="code" href="structdlist__node__t.html">dlist_node_t</a> *next_node = <a class="code" href="dlist_8h.html#a5d22ada75e1ef9d60ebe8d580f5ea05b">dlist_next</a>(dlist, current);</div>
<div class="line"><span class="comment">// Process next_node as needed</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dlist</td><td>A pointer to the circular doubly linked list. </td></tr>
    <tr><td class="paramname">existing_node</td><td>A pointer to the current node in the list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the next node in the list, which could be the list node itself. </dd></dl>

<p class="definition">Definition at line <a class="el" href="dlist_8h_source.html#l00134">134</a> of file <a class="el" href="dlist_8h_source.html">dlist.h</a>.</p>

</div>
</div>
<a id="a207dad2368bb8983a3fb2df6ca25a080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a207dad2368bb8983a3fb2df6ca25a080">&#9670;&nbsp;</a></span>DLIST_NODE_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DLIST_NODE_TYPE&#160;&#160;&#160;<a class="el" href="structdlist__node__t.html">dlist_node_t</a> dlist_node</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro to embed a list node in a structure for a circular doubly linked list. </p>
<p>Add <code>DLIST_NODE_TYPE</code> as the first member of a structure to make it suitable for use as a node in a circular doubly linked list. This macro defines an embedded <code><a class="el" href="structdlist__node__t.html" title="Structure representing a node in a circular doubly linked list.">dlist_node_t</a></code> structure, allowing any structure that includes it to be linked into a circular doubly linked list. The embedded <code><a class="el" href="structdlist__node__t.html" title="Structure representing a node in a circular doubly linked list.">dlist_node_t</a></code> structure is named <code>dlist_node</code>, and it contains the necessary pointers to the next and previous nodes in the list.</p>
<p>This approach allows for the creation of nodes that can store additional data while still being compatible with circular doubly linked list operations.</p>
<p>Usage: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">    <a class="code" href="dlist_8h.html#a207dad2368bb8983a3fb2df6ca25a080">DLIST_NODE_TYPE</a>; <span class="comment">// Embeds the list node</span></div>
<div class="line">    <span class="keywordtype">int</span> data;        <span class="comment">// Additional data field</span></div>
<div class="line">} custom_node_t;</div>
<div class="ttc" id="adlist_8h_html_a207dad2368bb8983a3fb2df6ca25a080"><div class="ttname"><a href="dlist_8h.html#a207dad2368bb8983a3fb2df6ca25a080">DLIST_NODE_TYPE</a></div><div class="ttdeci">#define DLIST_NODE_TYPE</div><div class="ttdoc">Macro to embed a list node in a structure for a circular doubly linked list.</div><div class="ttdef"><b>Definition:</b> <a href="dlist_8h_source.html#l00106">dlist.h:106</a></div></div>
</div><!-- fragment --><p>With this definition, <code>custom_node_t</code> can be used as a node in a circular doubly linked list, and additional data can be associated with each node. </p>

<p class="definition">Definition at line <a class="el" href="dlist_8h_source.html#l00106">106</a> of file <a class="el" href="dlist_8h_source.html">dlist.h</a>.</p>

</div>
</div>
<a id="a31e6ae1179141b1425f476b5d9423b71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31e6ae1179141b1425f476b5d9423b71">&#9670;&nbsp;</a></span>dlist_pop_back</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define dlist_pop_back</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dlist</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">do</span> { \</div>
<div class="line">        (dlist)-&gt;prev = (dlist)-&gt;prev-&gt;prev; \</div>
<div class="line">        (dlist)-&gt;prev-&gt;next = (dlist); \</div>
<div class="line">    }<span class="keywordflow">while</span>(0)</div>
</div><!-- fragment -->
<p>Removes the last element from a circular doubly linked list. </p>
<p>This macro removes the last element in the circular doubly linked list, effectively reducing the container's size by one. The removal is done by adjusting the 'prev' pointer of the list node (<code>dlist</code>) to point to the second-to-last node, and then setting the 'next' pointer of this new last node to point back to the list node. This effectively removes the original last node from the list.</p>
<p>The operation is efficient as it directly manipulates the pointers without needing to traverse the entire list. However, it is important to ensure that the list is not empty before calling this macro. If the list is empty (i.e., <code>dlist-&gt;prev</code> is <code>dlist</code>), calling <code>dlist_pop_back</code> will have no effect.</p>
<p>Users should also handle memory management for the removed node if it was dynamically allocated. This macro only removes the node from the list structure; it does not free the memory associated with the node.</p>
<p>Usage: </p><div class="fragment"><div class="line"><a class="code" href="structdlist__node__t.html">dlist_t</a> mylist;</div>
<div class="line"><a class="code" href="dlist_8h.html#a91b88be10a7e1ecc7763abae712aa7fc">dlist_init</a>(&amp;mylist);</div>
<div class="line"><span class="comment">// Add elements to the list</span></div>
<div class="line"><span class="keywordflow">if</span> (!<a class="code" href="dlist_8h.html#a32d6434a21efbaa32af5c6ea7778fbca">dlist_empty</a>(&amp;mylist)) {</div>
<div class="line">    <a class="code" href="dlist_8h.html#a31e6ae1179141b1425f476b5d9423b71">dlist_pop_back</a>(&amp;mylist);</div>
<div class="line">    <span class="comment">// The last node is now removed from &#39;mylist&#39;</span></div>
<div class="line">}</div>
<div class="ttc" id="adlist_8h_html_a31e6ae1179141b1425f476b5d9423b71"><div class="ttname"><a href="dlist_8h.html#a31e6ae1179141b1425f476b5d9423b71">dlist_pop_back</a></div><div class="ttdeci">#define dlist_pop_back(dlist)</div><div class="ttdoc">Removes the last element from a circular doubly linked list.</div><div class="ttdef"><b>Definition:</b> <a href="dlist_8h_source.html#l00519">dlist.h:519</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dlist</td><td>A pointer to the circular doubly linked list. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="dlist_8h_source.html#l00519">519</a> of file <a class="el" href="dlist_8h_source.html">dlist.h</a>.</p>

</div>
</div>
<a id="ab68129d82e32313b0174c636f735f80a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab68129d82e32313b0174c636f735f80a">&#9670;&nbsp;</a></span>dlist_pop_front</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define dlist_pop_front</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dlist</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">do</span>{ \</div>
<div class="line">        (dlist)-&gt;next = (dlist)-&gt;next-&gt;next; \</div>
<div class="line">        (dlist)-&gt;next-&gt;prev = (dlist); \</div>
<div class="line">    }<span class="keywordflow">while</span>(0);</div>
</div><!-- fragment -->
<p>Deletes the first node in a circular doubly linked list. </p>
<p>This macro removes the first node of the circular doubly linked list. It does this by setting the 'next' pointer of the list node (<code>dlist</code>) to point to the second node in the list, and then updating the 'prev' pointer of the new first node to point back to the list node. This effectively removes the original first node from the list.</p>
<p>The operation is efficient as it directly manipulates the pointers without needing to traverse the list. However, it is important to ensure that the list is not empty before calling this macro. If the list is empty (i.e., <code>dlist-&gt;next</code> is <code>dlist</code>), calling <code>dlist_pop_front</code> will have no effect.</p>
<p>Users should also handle memory management for the removed node if it was dynamically allocated. This macro only removes the node from the list structure; it does not free the memory associated with the node.</p>
<p>Usage: </p><div class="fragment"><div class="line"><a class="code" href="structdlist__node__t.html">dlist_t</a> mylist;</div>
<div class="line"><a class="code" href="dlist_8h.html#a91b88be10a7e1ecc7763abae712aa7fc">dlist_init</a>(&amp;mylist);</div>
<div class="line"><span class="comment">// Add elements to the list</span></div>
<div class="line"><span class="keywordflow">if</span> (!<a class="code" href="dlist_8h.html#a32d6434a21efbaa32af5c6ea7778fbca">dlist_empty</a>(&amp;mylist)) {</div>
<div class="line">    <a class="code" href="dlist_8h.html#ab68129d82e32313b0174c636f735f80a">dlist_pop_front</a>(&amp;mylist);</div>
<div class="line">    <span class="comment">// The first node is now removed from &#39;mylist&#39;</span></div>
<div class="line">}</div>
<div class="ttc" id="adlist_8h_html_ab68129d82e32313b0174c636f735f80a"><div class="ttname"><a href="dlist_8h.html#ab68129d82e32313b0174c636f735f80a">dlist_pop_front</a></div><div class="ttdeci">#define dlist_pop_front(dlist)</div><div class="ttdoc">Deletes the first node in a circular doubly linked list.</div><div class="ttdef"><b>Definition:</b> <a href="dlist_8h_source.html#l00442">dlist.h:442</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dlist</td><td>A pointer to the circular doubly linked list. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="dlist_8h_source.html#l00442">442</a> of file <a class="el" href="dlist_8h_source.html">dlist.h</a>.</p>

</div>
</div>
<a id="a79b530d7d8bc62657ffb605744bbc497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79b530d7d8bc62657ffb605744bbc497">&#9670;&nbsp;</a></span>dlist_prev</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define dlist_prev</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dlist, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">existing_node&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    (((<a class="el" href="structdlist__node__t.html">dlist_node_t</a>*)(existing_node))-&gt;prev)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the previous node in a circular doubly linked list. </p>
<p>This macro is designed to access the predecessor of a given node (<code>existing_node</code>) in a circular doubly linked list. It returns the node that immediately precedes the specified node in the list. This macro is particularly useful for reverse iteration over a circular doubly linked list, where each node is linked to both its next and previous nodes.</p>
<p>The macro assumes that <code>existing_node</code> is not NULL and is a valid member of the list. If <code>existing_node</code> is the first node in the list (after the list node), <code>dlist_prev</code> returns the list node itself, which is the predecessor in the circular structure of the list.</p>
<p>Usage: </p><div class="fragment"><div class="line"><a class="code" href="structdlist__node__t.html">dlist_node_t</a> *current = get_some_node(dlist);</div>
<div class="line"><a class="code" href="structdlist__node__t.html">dlist_node_t</a> *previous_node = <a class="code" href="dlist_8h.html#a79b530d7d8bc62657ffb605744bbc497">dlist_prev</a>(dlist, current);</div>
<div class="line"><span class="comment">// Process previous_node as needed</span></div>
<div class="ttc" id="adlist_8h_html_a79b530d7d8bc62657ffb605744bbc497"><div class="ttname"><a href="dlist_8h.html#a79b530d7d8bc62657ffb605744bbc497">dlist_prev</a></div><div class="ttdeci">#define dlist_prev(dlist, existing_node)</div><div class="ttdoc">Retrieves the previous node in a circular doubly linked list.</div><div class="ttdef"><b>Definition:</b> <a href="dlist_8h_source.html#l00162">dlist.h:162</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dlist</td><td>A pointer to the circular doubly linked list. </td></tr>
    <tr><td class="paramname">existing_node</td><td>A pointer to the current node in the list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the previous node in the list, which could be the list node itself. </dd></dl>

<p class="definition">Definition at line <a class="el" href="dlist_8h_source.html#l00162">162</a> of file <a class="el" href="dlist_8h_source.html">dlist.h</a>.</p>

</div>
</div>
<a id="aab234e0b85f3f015ac0419939efb4987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab234e0b85f3f015ac0419939efb4987">&#9670;&nbsp;</a></span>dlist_push_back</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define dlist_push_back</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dlist, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node_to_add&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">do</span> { \</div>
<div class="line">        ((<a class="code" href="structdlist__node__t.html">dlist_node_t</a>*)(node_to_add))-&gt;next = (dlist); \</div>
<div class="line">        ((<a class="code" href="structdlist__node__t.html">dlist_node_t</a>*)(node_to_add))-&gt;prev = (dlist)-&gt;prev; \</div>
<div class="line">        (dlist)-&gt;prev-&gt;next = ((<a class="code" href="structdlist__node__t.html">dlist_node_t</a>*)(node_to_add)); \</div>
<div class="line">        (dlist)-&gt;prev = ((<a class="code" href="structdlist__node__t.html">dlist_node_t</a>*)(node_to_add)); \</div>
<div class="line">    }<span class="keywordflow">while</span>(0)</div>
</div><!-- fragment -->
<p>Inserts an element at the end of a circular doubly linked list. </p>
<p>This macro inserts a new node (<code>node_to_add</code>) at the end of the circular doubly linked list, right after the current last node. The insertion is achieved by adjusting the 'next' and 'prev' pointers of the new node, as well as the 'prev' pointer of the list node and the 'next' pointer of the original last node in the list.</p>
<p>This operation is efficient as it directly manipulates the pointers without needing to traverse the list. After insertion, the new node becomes the last element of the list. It is important to ensure that <code>node_to_add</code> is properly allocated and initialized before using this macro. Additionally, the list must be correctly initialized for this macro to function as expected.</p>
<p>Usage: </p><div class="fragment"><div class="line"><a class="code" href="structdlist__node__t.html">dlist_t</a> mylist;</div>
<div class="line"><a class="code" href="dlist_8h.html#a91b88be10a7e1ecc7763abae712aa7fc">dlist_init</a>(&amp;mylist);</div>
<div class="line"><a class="code" href="structdlist__node__t.html">dlist_node_t</a> *new_node = create_node(data); <span class="comment">// Assume create_node allocates and initializes a new node</span></div>
<div class="line"><a class="code" href="dlist_8h.html#aab234e0b85f3f015ac0419939efb4987">dlist_push_back</a>(&amp;mylist, new_node);</div>
<div class="line"><span class="comment">// Now &#39;new_node&#39; is the last element of &#39;mylist&#39;</span></div>
<div class="ttc" id="adlist_8h_html_aab234e0b85f3f015ac0419939efb4987"><div class="ttname"><a href="dlist_8h.html#aab234e0b85f3f015ac0419939efb4987">dlist_push_back</a></div><div class="ttdeci">#define dlist_push_back(dlist, node_to_add)</div><div class="ttdoc">Inserts an element at the end of a circular doubly linked list.</div><div class="ttdef"><b>Definition:</b> <a href="dlist_8h_source.html#l00477">dlist.h:477</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dlist</td><td>A pointer to the circular doubly linked list. </td></tr>
    <tr><td class="paramname">node_to_add</td><td>A pointer to the node to be added to the end of the list. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="dlist_8h_source.html#l00477">477</a> of file <a class="el" href="dlist_8h_source.html">dlist.h</a>.</p>

</div>
</div>
<a id="a65124d2ea3f72b8fb6f511d89e74c0d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65124d2ea3f72b8fb6f511d89e74c0d1">&#9670;&nbsp;</a></span>dlist_push_front</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define dlist_push_front</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dlist, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node_to_add&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">do</span>{ \</div>
<div class="line">        ((<a class="code" href="structdlist__node__t.html">dlist_node_t</a>*)(node_to_add))-&gt;next = (dlist)-&gt;next; \</div>
<div class="line">        ((<a class="code" href="structdlist__node__t.html">dlist_node_t</a>*)(node_to_add))-&gt;prev = (dlist); \</div>
<div class="line">        (dlist)-&gt;next-&gt;prev = ((<a class="code" href="structdlist__node__t.html">dlist_node_t</a>*)(node_to_add)); \</div>
<div class="line">        (dlist)-&gt;next = ((<a class="code" href="structdlist__node__t.html">dlist_node_t</a>*)(node_to_add)); \</div>
<div class="line">    }<span class="keywordflow">while</span>(0);</div>
</div><!-- fragment -->
<p>Inserts an element at the beginning of a circular doubly linked list. </p>
<p>This macro inserts a new node (<code>node_to_add</code>) at the beginning of the circular doubly linked list, right before its current first element. The insertion is done by adjusting the 'next' and 'prev' pointers of the node to add, as well as the 'next' pointer of the list node and the 'prev' pointer of the original first element of the list.</p>
<p>This operation is efficient as it does not require traversing the list and directly modifies the necessary pointers to insert the new node. After insertion, the new node becomes the first element of the list.</p>
<p>It is important to ensure that <code>node_to_add</code> is properly allocated and initialized before using this macro. Additionally, the list must be correctly initialized for this macro to function as expected.</p>
<p>Usage: </p><div class="fragment"><div class="line"><a class="code" href="structdlist__node__t.html">dlist_t</a> mylist;</div>
<div class="line"><a class="code" href="dlist_8h.html#a91b88be10a7e1ecc7763abae712aa7fc">dlist_init</a>(&amp;mylist);</div>
<div class="line"><a class="code" href="structdlist__node__t.html">dlist_node_t</a> *new_node = create_node(data); <span class="comment">// Assume create_node allocates and initializes a new node</span></div>
<div class="line"><a class="code" href="dlist_8h.html#a65124d2ea3f72b8fb6f511d89e74c0d1">dlist_push_front</a>(&amp;mylist, new_node);</div>
<div class="line"><span class="comment">// Now &#39;new_node&#39; is the first element of &#39;mylist&#39;</span></div>
<div class="ttc" id="adlist_8h_html_a65124d2ea3f72b8fb6f511d89e74c0d1"><div class="ttname"><a href="dlist_8h.html#a65124d2ea3f72b8fb6f511d89e74c0d1">dlist_push_front</a></div><div class="ttdeci">#define dlist_push_front(dlist, node_to_add)</div><div class="ttdoc">Inserts an element at the beginning of a circular doubly linked list.</div><div class="ttdef"><b>Definition:</b> <a href="dlist_8h_source.html#l00403">dlist.h:403</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dlist</td><td>A pointer to the circular doubly linked list. </td></tr>
    <tr><td class="paramname">node_to_add</td><td>A pointer to the node to be added to the beginning of the list. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="dlist_8h_source.html#l00403">403</a> of file <a class="el" href="dlist_8h_source.html">dlist.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a0a945596fd137b14273b421383b45734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a945596fd137b14273b421383b45734">&#9670;&nbsp;</a></span>dlist_node_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structdlist__node__t.html">dlist_node_t</a> <a class="el" href="structdlist__node__t.html">dlist_node_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for the structure representing a node in a circular doubly linked list. </p>

<p class="definition">Definition at line <a class="el" href="dlist_8h_source.html#l00001">1</a> of file <a class="el" href="dlist_8h_source.html">dlist.h</a>.</p>

</div>
</div>
<a id="af95cb0e87f5c2fc68cda38f6b98c77b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af95cb0e87f5c2fc68cda38f6b98c77b7">&#9670;&nbsp;</a></span>dlist_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structdlist__node__t.html">dlist_node_t</a> <a class="el" href="dlist_8h.html#af95cb0e87f5c2fc68cda38f6b98c77b7">dlist_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for the circular doubly linked list. </p>
<p>This typedef is used to create an instance of a circular doubly linked list. It defines a list node type (<code><a class="el" href="structdlist__node__t.html" title="Structure representing a node in a circular doubly linked list.">dlist_node_t</a></code>) which also acts as the head of the list. The list instance itself is a member of the list, simplifying list operations by eliminating special cases for the head of the list. List instance is also a member of the list </p>

<p class="definition">Definition at line <a class="el" href="dlist_8h_source.html#l00681">681</a> of file <a class="el" href="dlist_8h_source.html">dlist.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aba7d109449bb740a61d7e8558b1c9321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba7d109449bb740a61d7e8558b1c9321">&#9670;&nbsp;</a></span>dlist_find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdlist__node__t.html">dlist_node_t</a>* dlist_find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dlist_8h.html#af95cb0e87f5c2fc68cda38f6b98c77b7">dlist_t</a> *&#160;</td>
          <td class="paramname"><em>dlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a node is in the circular doubly linked list. </p>
<p>This function iterates through the circular doubly linked list and checks if a specific node (<code>node</code>) is present in the list. It uses a linear search, comparing each node's address with the address of the specified node. If the node is found, the function returns a pointer to that node; otherwise, it returns NULL.</p>
<p>The search is performed using the <code>dlist_foreach</code> macro, which iterates over each node in the list. This function is useful for verifying the presence of a node in the list before performing operations that depend on its existence in the list.</p>
<dl class="section note"><dt>Note</dt><dd>The function assumes that the list is properly initialized and the <code>node</code> pointer is valid. The function runs in linear time complexity, as it may need to traverse the entire list to find the node or determine its absence.</dd></dl>
<p>Usage: </p><div class="fragment"><div class="line"><a class="code" href="structdlist__node__t.html">dlist_t</a> mylist;</div>
<div class="line"><a class="code" href="dlist_8h.html#a91b88be10a7e1ecc7763abae712aa7fc">dlist_init</a>(&amp;mylist);</div>
<div class="line"><span class="comment">// Add elements to the list</span></div>
<div class="line"><a class="code" href="structdlist__node__t.html">dlist_node_t</a> *search_node = create_node(data); <span class="comment">// Assume create_node allocates and initializes a new node</span></div>
<div class="line"><a class="code" href="dlist_8h.html#aab234e0b85f3f015ac0419939efb4987">dlist_push_back</a>(&amp;mylist, search_node);</div>
<div class="line"><span class="comment">// Now search for the node</span></div>
<div class="line"><a class="code" href="structdlist__node__t.html">dlist_node_t</a> *found_node = <a class="code" href="dlist_8c.html#aba7d109449bb740a61d7e8558b1c9321">dlist_find</a>(&amp;mylist, search_node);</div>
<div class="line"><span class="keywordflow">if</span> (found_node) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;Node found in the list\n&quot;</span>);</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    printf(<span class="stringliteral">&quot;Node not found in the list\n&quot;</span>);</div>
<div class="line">}</div>
<div class="ttc" id="adlist_8c_html_aba7d109449bb740a61d7e8558b1c9321"><div class="ttname"><a href="dlist_8c.html#aba7d109449bb740a61d7e8558b1c9321">dlist_find</a></div><div class="ttdeci">dlist_node_t * dlist_find(dlist_t *dlist, void *node)</div><div class="ttdoc">Checks if a node is in the circular doubly linked list.</div><div class="ttdef"><b>Definition:</b> <a href="dlist_8c_source.html#l00061">dlist.c:61</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dlist</td><td>A pointer to the circular doubly linked list. </td></tr>
    <tr><td class="paramname">node</td><td>The node to search for in the list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the node if it exists in the list, NULL otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="dlist_8c_source.html#l00061">61</a> of file <a class="el" href="dlist_8c_source.html">dlist.c</a>.</p>

</div>
</div>
<a id="a643bd1eb05da6561fcf98ea81bf160c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a643bd1eb05da6561fcf98ea81bf160c6">&#9670;&nbsp;</a></span>dlist_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t dlist_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dlist_8h.html#af95cb0e87f5c2fc68cda38f6b98c77b7">dlist_t</a> *&#160;</td>
          <td class="paramname"><em>dlist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of nodes in a circular doubly linked list. </p>
<p>This function calculates and returns the number of elements (nodes) present in a circular doubly linked list, excluding the list node itself. It traverses the list starting from the first element after the list node and counts each node until it reaches the list node again.</p>
<p>This traversal makes use of the <code>dlist_foreach</code> macro, which iterates over each node in the list. The function is useful for determining the size of the list for various operations such as allocation, serialization, or applying algorithms that depend on the number of elements.</p>
<dl class="section note"><dt>Note</dt><dd>The function assumes that the list is properly initialized. An uninitialized or improperly formed list might lead to undefined behavior. The function runs in linear time complexity, as it traverses each element of the list.</dd></dl>
<p>Usage: </p><div class="fragment"><div class="line"><a class="code" href="structdlist__node__t.html">dlist_t</a> mylist;</div>
<div class="line"><a class="code" href="dlist_8h.html#a91b88be10a7e1ecc7763abae712aa7fc">dlist_init</a>(&amp;mylist);</div>
<div class="line"><span class="comment">// Add elements to the list</span></div>
<div class="line"><span class="keywordtype">size_t</span> list_size = <a class="code" href="dlist_8c.html#a643bd1eb05da6561fcf98ea81bf160c6">dlist_size</a>(&amp;mylist);</div>
<div class="line">printf(<span class="stringliteral">&quot;List contains %zu elements\n&quot;</span>, list_size);</div>
<div class="ttc" id="adlist_8c_html_a643bd1eb05da6561fcf98ea81bf160c6"><div class="ttname"><a href="dlist_8c.html#a643bd1eb05da6561fcf98ea81bf160c6">dlist_size</a></div><div class="ttdeci">size_t dlist_size(dlist_t *dlist)</div><div class="ttdoc">Counts the number of nodes in a circular doubly linked list.</div><div class="ttdef"><b>Definition:</b> <a href="dlist_8c_source.html#l00077">dlist.c:77</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dlist</td><td>A pointer to the circular doubly linked list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the list, excluding the list node itself. </dd></dl>

<p class="definition">Definition at line <a class="el" href="dlist_8c_source.html#l00077">77</a> of file <a class="el" href="dlist_8c_source.html">dlist.c</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_31203ee4bd5a40761b5a1bacfafff785.html">myos</a></li><li class="navelem"><a class="el" href="dir_ab5651bb529f81acb9f66f76269f425b.html">lib</a></li><li class="navelem"><a class="el" href="dlist_8h.html">dlist.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
